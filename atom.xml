<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OBKoro1&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-18T14:23:00.468Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>OBKoro1</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端笔试题面试题记录（上）</title>
    <link href="http://yoursite.com/2018/03/18/3%E6%9C%88%E5%88%9D%E4%B8%8A%E6%B5%B7%E5%89%8D%E7%AB%AF%E9%81%87%E5%88%B0%E7%AC%94%E8%AF%95%E9%A2%98%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/03/18/3月初上海前端遇到笔试题面试题记录/</id>
    <published>2018-03-18T10:13:59.000Z</published>
    <updated>2018-03-18T14:23:00.468Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>过完元宵，就到上海找了波工作，现在已经入职好了，本文的题目都是中小公司的笔试面试题，里面大部分是我碰到比较频繁或者印象深刻的，在此做波记录，如果喜欢的话可以点波赞，或者关注一下，希望大家看完本文可以有所收获。</p><blockquote><p>本文首发于我的个人blog：<a href="http://obkoro1.com/" target="_blank" rel="external">obkoro1.com</a></p></blockquote><hr><h3 id="Q：什么情况下会碰到跨域问题？有哪些解决方法？"><a href="#Q：什么情况下会碰到跨域问题？有哪些解决方法？" class="headerlink" title="Q：什么情况下会碰到跨域问题？有哪些解决方法？"></a>Q：什么情况下会碰到跨域问题？有哪些解决方法？</h3><ul><li>跨域问题是这是浏览器为了安全实施的同源策略导致的，同源策略限制了来自不同源的<code>document</code>、<code>脚本</code>，同源的意思就是<strong>两个URL的域名、协议、端口要完全相同。</strong></li><li>script标签jsonp跨域、nginx反向代理、node.js中间件代理跨域、后端在头部信息设置安全域名、后端在服务器上设置cors。</li></ul><hr><h3 id="Q：如何判断一个变量是对象还是数组？"><a href="#Q：如何判断一个变量是对象还是数组？" class="headerlink" title="Q：如何判断一个变量是对象还是数组？"></a>Q：如何判断一个变量是对象还是数组？</h3><p>判断数组和对象分别都有好几种方法，其中用<code>prototype.toString.call()</code>兼容性最好。</p><pre><code>function isObjArr(variable){     if (Object.prototype.toString.call(value) === &quot;[object Array]&quot;) {            console.log(&apos;value是数组&apos;);       }else if(Object.prototype.toString.call(value)===&apos;[object Object]&apos;){//这个方法兼容性好一点            console.log(&apos;value是对象&apos;);      }else{          console.log(&apos;value不是数组也不是对象&apos;)      }}</code></pre><p>ps：<strong>千万不能使用typeof来判断对象和数组</strong>，因为这两种类型都会返回”object”。</p><hr><h3 id="Q：定时器的执行顺序或机制。"><a href="#Q：定时器的执行顺序或机制。" class="headerlink" title="Q：定时器的执行顺序或机制。"></a>Q：定时器的执行顺序或机制。</h3><p>这个问题还是挺经常被问到的，有一些会直接问定时器的机制，有一些是通过笔试题的方式问执行顺序然后问我为什么是这样。</p><p>长话短说，我们需要记住的是：<strong>因为js是单线程的，浏览器遇到<code>setTimeout</code>或者<code>setInterval</code>会先执行完当前的代码块，在此之前会把定时器推入浏览器的待执行事件队列里面，等到浏览器执行完当前代码之后会看一下事件队列里面有没有任务，有的话才执行定时器的代码。</strong> 所以即使把定时器的时间设置为0还是会先执行当前的一些代码。</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/18/1623523c039e18f5?w=478&amp;h=489&amp;f=png&amp;s=30591" alt=""></p><p>上面是我写的一个栗子，如果还不清楚的话，大家可以找一篇关于定时器机制的详解文章来看看。</p><hr><h3 id="Q：html中title属性和alt属性的区别？"><a href="#Q：html中title属性和alt属性的区别？" class="headerlink" title="Q：html中title属性和alt属性的区别？"></a>Q：html中title属性和alt属性的区别？</h3><p>这个问题被问了一次，当时我只记得，alt属性是用于img标签的，当图片失效的时候会出现alt属性里面的内容，title用来标记页面的title，当时面试官问我还有没有其他的区别。我。。。</p><p>然后我就找了一篇文章来看，涨了点姿势：</p><pre><code>1.&lt;img src=&quot;#&quot; alt=&quot;alt信息&quot; /&gt;//1.当图片不输出信息的时候，会显示alt信息 鼠标放上去没有信息，当图片正常读取，不会出现alt信息2.&lt;img src=&quot;#&quot; alt=&quot;alt信息&quot; title=&quot;title信息&quot; /&gt;// 2.当图片不输出信息的时候，会显示alt信息 鼠标放上去会出现title信息//当图片正常输出的时候，不会出现alt信息，鼠标放上去会出现title信息</code></pre><p>另外还有一些关于title属性的知识：</p><pre><code>title属性可以用在除了base，basefont，head，html，meta，param，script和title之外的所有标签title属性的功能是提示。额外的说明信息和非本质的信息请使用title属性。title属性值可以比alt属性值设置的更长title属性有一个很好的用途，即为链接添加描述性文字，特别是当连接本身并不是十分清楚的表达了链接的目的。</code></pre><hr><h3 id="Q：标准盒子模型与IE怪异盒子模型"><a href="#Q：标准盒子模型与IE怪异盒子模型" class="headerlink" title="Q：标准盒子模型与IE怪异盒子模型"></a>Q：标准盒子模型与IE怪异盒子模型</h3><p>这个问题主要会出现在笔试题上面，比如：</p><pre><code>&lt;div style=&quot;width:100px;height=&quot;100px;border:10px;padding:10px;&quot;&gt;&lt;/div&gt;</code></pre><p>这个盒子在w3c标准盒子模型和IE的怪异盒子模型下面它的宽度分别是多少？</p><pre><code>标准盒子模型：总宽度=content100px+border 10px*2+padding 10px*2 //140px怪异盒子模型: 总宽度=content60px+ border 10px*2+padding 10px*2 //100px</code></pre><p>ps：</p><pre><code>box-sizing： content-box || border-box；//css3 box-sizing设置为border-box将使用怪异盒子模型当怪异盒子的宽度小于border+padding的宽度的时候，content width将变为0，盒子的宽度会被border和padding的总宽度撑开</code></pre><hr><h3 id="ES5的继承和ES6的继承有什么区别？"><a href="#ES5的继承和ES6的继承有什么区别？" class="headerlink" title="ES5的继承和ES6的继承有什么区别？"></a>ES5的继承和ES6的继承有什么区别？</h3><p>ES5的继承时通过prototype或构造函数机制来实现。<strong>ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上</strong>（Parent.apply(this)）。</p><p>ES6的继承机制完全不同，<strong>实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this</strong>。</p><p>具体的：ES6通过class关键字定义类，里面有构造方法，类之间通过extends关键字实现继承。子类必须在constructor方法中调用super方法，否则新建实例报错。因为子类没有自己的this对象，而是继承了父类的this对象，然后对其进行加工。如果不调用super方法，子类得不到this对象。</p><p>ps：super关键字指代父类的实例，即父类的this对象。在子类构造函数中，调用super后，才可使用this关键字，否则报错。</p><hr><h3 id="Q：CSS3有哪些新增的属性？"><a href="#Q：CSS3有哪些新增的属性？" class="headerlink" title="Q：CSS3有哪些新增的属性？"></a>Q：CSS3有哪些新增的属性？</h3><pre><code>这里可以分为边框、背景，渐变，阴影、2D转换 3D转换等之类的来说。比如：边框(border-radius、border-shadow、border-image)之类的 。</code></pre><p>具体的可以参见菜鸟教程：<a href="http://www.runoob.com/css3/css3-tutorial.html" target="_blank" rel="external">链接</a>。类似的镜像问题还有HTML5的新增属性，可以自己谷歌一下。</p><hr><h3 id="Q：你知道哪些http状态码？"><a href="#Q：你知道哪些http状态码？" class="headerlink" title="Q：你知道哪些http状态码？"></a>Q：你知道哪些http状态码？</h3><pre><code>1xx：1开头的是信息状态码2xx：2开头的是请求成功3xx：3开头的是重定向4xx：4开头的是客户端错误5xx：5开头的是服务器错误</code></pre><p>这个问题并不难，在笔试面试都有碰到过，巧的是之前我就总结过一篇类似的<a href="https://juejin.im/post/590082e6a22b9d0065be1a5c" target="_blank" rel="external">文章</a>。</p><hr><h3 id="Q-如何对一个数组去重？"><a href="#Q-如何对一个数组去重？" class="headerlink" title="Q:如何对一个数组去重？"></a>Q:如何对一个数组去重？</h3><p>这个问题出现了好几次，而且很多面试官不满足你只给出一两种方法。</p><p>1、<strong>Set结构去重</strong>。</p><p>这是ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><pre><code>let unique= [...new Set(array)];//es6 Set数据结构类似于数组，成员值是唯一的，有重复的值会自动去重。//Set内部使用===来判断是否相等，类似&apos;1&apos;和1会两个都保存，NaN和NaN只会保存一个</code></pre><p>2、遍历，将值添加到新数组，<strong>用indexOf()判断值是否存在，已存在就不添加</strong>，达到去重效果。</p><pre><code>    let a = [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;,1,NaN,NaN,undefined,undefined,null,null, &apos;a&apos;,&apos;b&apos;,&apos;b&apos;];    let unique= arr =&gt;{         let newA=[];        arr.forEach(key =&gt; {           if( newA.indexOf(key)&lt;0 ){ //遍历newA是否存在key，如果存在key会大于0就跳过push的那一步             newA.push(key);           }        });        return newA;    }    console.log(unique(a)) ;//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, 1, NaN, NaN, undefined, null, &quot;a&quot;, &quot;b&quot;]//ps:这个方法不能分辨NaN,会出现两个NaN。是有问题的，下面那个方法好一点。</code></pre><p>3、遍历，将数组的值添加到一个对象的属性名里，并给属性赋值，<strong>对象不能添加相同属性名，以这个为依据可以实现数组去重</strong>，然后用<code>Object.keys(对象)</code>返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组。</p><pre><code>let a = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, 1,NaN,NaN,undefined,undefined,null,null, &apos;a&apos;, &apos;b&apos;, &apos;b&apos;];const unique = arr =&gt; {    var obj = {}    arr.forEach(value =&gt; {        obj[value] = 0;//这步新添加一个属性，并赋值，如果不赋值的话，属性会添加不上去    })    return Object.keys(obj);//`Object.keys(对象)`返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组}console.log(unique(a));//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;NaN&quot;, &quot;undefined&quot;, &quot;null&quot;, &quot;a&quot;, &quot;b&quot;]</code></pre><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>这个方法会将 number,NaN,undefined,null，<strong>变为字符串形式，因为对象的属性名就是一个字符串</strong>，根据需求来吧，想想还是Set去重最简单也最有效。</p><hr><h3 id="Q：垂直居中有哪些方法？"><a href="#Q：垂直居中有哪些方法？" class="headerlink" title="Q：垂直居中有哪些方法？"></a>Q：垂直居中有哪些方法？</h3><ul><li>单行文本的话可以使用<code>height和line-height</code>设置同一高度。</li><li><code>position+margin</code>：设置父元素:<code>position: relative;</code>，子元素<code>height: 100px; position:absolute;top: 50%; margin: -50px 0 0 0;</code>（定高）</li><li><code>position+transform</code>：设置父元素<code>position:relative</code>,子元素：<code>position: absolute;top: 50%;transform: translate(0, -50%);</code>（不定高）</li><li>百搭flex布局(ie10+)，设置父元素<code>display:flex;align-items: center;</code>（不定高）</li></ul><p>类似的还有很多，实际应用中，可能就会使用一两种方法，有兴趣的可以看下这篇<a href="https://www.cnblogs.com/zhouhuan/p/vertical_center.html" target="_blank" rel="external">文章</a></p><hr><h3 id="Q：翻转一个字符串"><a href="#Q：翻转一个字符串" class="headerlink" title="Q：翻转一个字符串"></a>Q：翻转一个字符串</h3><p>这个问题主要在笔试题碰到的多，思路就是先将字符串转成一个数组，然后用数组的<code>reverse()+join()</code>方法。</p><pre><code>let a=&quot;hello word&quot;;let b=[...str].reverse().join(&quot;&quot;);//drow olleh</code></pre><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我想说的是：在找工作期间，肯定有自己发挥不好，或者不会的问题，一定要在晚上的时候自己再学习总结一下，在一个问题上面尽量不要栽倒两次，学到了的才是自己的。</p><p>以上就是近期面试遇到的一些问题记录总结，实际上还是有一些问题没有写出来，许久没有写文章了，写的很慢，有点累。先给自己立一个flag，下周再写一篇出来。希望各位大佬看了本文，能有所收获，感谢阅读。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><strong><a href="http://obkoro1.com/" target="_blank" rel="external">个人blog</a></strong> and <strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a></strong>  </p><p>以上2018.3.18</p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://www.cnblogs.com/yoyo24456/archive/2014/07/04/3823728.html" target="_blank" rel="external">title与alt的区别</a></p><p><a href="http://blog.csdn.net/dong_pt/article/details/51281372" target="_blank" rel="external">CSS-标准盒模型 &amp; 怪异盒模型</a></p><p><a href="https://juejin.im/post/5a7aaf745188257a5a4c9a39" target="_blank" rel="external">常见的js算法面试题收集，es6实现</a></p><p><a href="https://www.cnblogs.com/zhouhuan/p/vertical_center.html" target="_blank" rel="external">CSS垂直居中的11种实现方式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;过完元宵，就到上海找了波工作，现在已经入职好了，本文的题目都是中小公司的笔试面试题，里面大部分是我碰到比较频繁或者印象深刻的，在此做波记录，
      
    
    </summary>
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>Vue实践过程中的几个问题</title>
    <link href="http://yoursite.com/2018/01/17/Vue%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/01/17/Vue实践过程中的几个问题/</id>
    <published>2018-01-16T18:00:12.000Z</published>
    <updated>2018-01-16T18:10:52.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇是我在使用vue过程中，遇到的几个小问题和之前不了解的东西，记录下来，希望能够帮助各位踩坑。如果喜欢的话可以点波赞，或者关注一下，希望本文可以帮到大家。</p><blockquote><p>本文首发于我的个人blog：<a href="http://obkoro1.com/" target="_blank" rel="external">obkoro1.com</a></p></blockquote><h2 id="本篇记录个人遇到的问题如下"><a href="#本篇记录个人遇到的问题如下" class="headerlink" title="本篇记录个人遇到的问题如下:"></a>本篇记录个人遇到的问题如下:</h2><ol><li>路由变化页面数据不刷新问题</li><li>setTimeout/setInterval this指向改变，无法用this访问VUe实例</li><li>setInterval路由跳转继续运行并没有销毁</li><li>vue 滚动行为(浏览器回退记忆位置)用法</li><li>vue路由拦截浏览器后退实现草稿保存类似需求</li><li>v-once 只渲染元素和组件一次，优化更新渲染性能</li><li>vue框架<a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="external">风格指南</a>推荐</li></ol><h2 id="路由变化页面数据不刷新问题"><a href="#路由变化页面数据不刷新问题" class="headerlink" title="路由变化页面数据不刷新问题"></a>路由变化页面数据不刷新问题</h2><blockquote><p>场景：比如文章详情数据，依赖路由的<code>params</code>参数获取的(ajax写在created生命周期里面)，因为路由懒加载的关系，退出页面再进入另一个文章页面并不会运行created组件生命周期，导致文章数据还是上一个文章的数据。</p></blockquote><h3 id="解决方法：watch监听路由是否变化"><a href="#解决方法：watch监听路由是否变化" class="headerlink" title="解决方法：watch监听路由是否变化"></a>解决方法：watch监听路由是否变化</h3><pre><code> watch: {  &apos;$route&apos; (to, from) { //监听路由是否变化    if(this.$route.params.articleId){//是否有文章id      //获取文章数据    }  }}</code></pre><h2 id="setTimeout-setInterval-this指向改变，无法用this访问VUe实例"><a href="#setTimeout-setInterval-this指向改变，无法用this访问VUe实例" class="headerlink" title="setTimeout/setInterval this指向改变，无法用this访问VUe实例"></a>setTimeout/setInterval this指向改变，无法用this访问VUe实例</h2><h3 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h3><pre><code>mounted(){       setTimeout(function () { //setInterval同理         console.log(this);//此时this指向Window对象      },1000);  }</code></pre><h3 id="解决方法：使用箭头函数或者"><a href="#解决方法：使用箭头函数或者" class="headerlink" title="解决方法：使用箭头函数或者"></a>解决方法：使用箭头函数或者</h3><pre><code>//箭头函数访问this实例 因为箭头函数本身没有绑定this setTimeout(() =&gt; {    console.log(this);}, 500);//使用变量访问this实例let self=this;    setTimeout(function () {        console.log(self);//使用self变量访问this实例    },1000);</code></pre><h2 id="setInterval路由跳转继续运行并没有销毁"><a href="#setInterval路由跳转继续运行并没有销毁" class="headerlink" title="setInterval路由跳转继续运行并没有销毁"></a>setInterval路由跳转继续运行并没有销毁</h2><h3 id="场景：-1"><a href="#场景：-1" class="headerlink" title="场景："></a>场景：</h3><p>比如一些弹幕，走马灯文字，这类需要定时调用的，路由跳转之后，因为组件已经销毁了，但是setInterval还没有销毁，还在继续后台调用，控制台会不断报错，如果运算量大的话，无法及时清除，会导致严重的页面卡顿。</p><h3 id="解决办法：在组件生命周期beforeDestroy停止setInterval"><a href="#解决办法：在组件生命周期beforeDestroy停止setInterval" class="headerlink" title="解决办法：在组件生命周期beforeDestroy停止setInterval"></a>解决办法：在组件生命周期beforeDestroy停止setInterval</h3><p>组件销毁前执行的钩子函数，跟其他生命周期钩子函数的用法相同。</p><pre><code>beforeDestroy(){     //我通常是把setInterval()定时器赋值给this实例，然后就可以像下面这么暂停。    clearInterval(this.intervalid);},</code></pre><h2 id="vue-滚动行为-浏览器回退记忆位置-用法"><a href="#vue-滚动行为-浏览器回退记忆位置-用法" class="headerlink" title="vue 滚动行为(浏览器回退记忆位置)用法"></a>vue 滚动行为(浏览器回退记忆位置)用法</h2><p>这个我当时做的时候以为很难，后来做好了才发现就是一个设置而已（前提是要开启路由的History 模式），下面做一个简单的分享。</p><h3 id="路由设置"><a href="#路由设置" class="headerlink" title="路由设置"></a>路由设置</h3><ol><li>要使用这一功能，首先需要开启vue-router的 <a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="external">history模式</a></li></ol><p>如果之前一直使用的是<code>hash</code>模式(默认模式)，项目已经开发了一段时间，然后转history模式很可能会遇到：<a href="https://juejin.im/post/5a3f629cf265da430d5839ed" target="_blank" rel="external">这些问题</a></p><ol><li><p>滚动行为具体设置如下：</p><pre><code>const router = new VueRouter({  mode: &apos;history&apos;,scrollBehavior (to, from, savedPosition) {    if (savedPosition) { //如果savedPosition存在，滚动条会自动跳到记录的值的地方      return savedPosition    } else {      return { x: 0, y: 0 }//savedPosition也是一个记录x轴和y轴位置的对象     }    }，  routes: [...]})</code></pre></li></ol><p><a href="https://router.vuejs.org/zh-cn/advanced/scroll-behavior.html" target="_blank" rel="external">vue滚动行为文档</a>，可以进到这里看看更详细的信息。</p><h2 id="vue路由拦截浏览器后退实现草稿保存类似需求"><a href="#vue路由拦截浏览器后退实现草稿保存类似需求" class="headerlink" title="vue路由拦截浏览器后退实现草稿保存类似需求"></a>vue路由拦截浏览器后退实现草稿保存类似需求</h2><h3 id="场景：-2"><a href="#场景：-2" class="headerlink" title="场景："></a>场景：</h3><p>为了防止用户突然离开，没有保存已输入的信息。</p><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><pre><code>//在路由组件中：mounted(){},beforeRouteLeave (to, from, next) {  if(用户已经输入信息){    //出现弹窗提醒保存草稿，或者自动后台为其保存  }else{    next(true);//用户离开  }</code></pre><p>类似的还有<code>beforeEach</code>、<code>beforeRouteUpdate</code>，也分为全局钩子和组件钩子，见<a href="https://router.vuejs.org/zh-cn/advanced/navigation-guards.html" target="_blank" rel="external">路由文档</a>。</p><h2 id="v-once-只渲染元素和组件一次，优化更新渲染性能"><a href="#v-once-只渲染元素和组件一次，优化更新渲染性能" class="headerlink" title="v-once 只渲染元素和组件一次，优化更新渲染性能"></a>v-once 只渲染元素和组件一次，优化更新渲染性能</h2><p>觉得<a href="https://cn.vuejs.org/v2/api/#v-cloak" target="_blank" rel="external">v-once</a>这个api蛮6的，应该很多小伙伴都没有注意到这个api。</p><h3 id="文档介绍："><a href="#文档介绍：" class="headerlink" title="文档介绍："></a>文档介绍：</h3><p><img src="https://user-gold-cdn.xitu.io/2018/1/17/160ffd6c2dcf70e1?w=948&amp;h=716&amp;f=png&amp;s=64938" alt="v-once文档介绍"></p><p>这个api在我看来主要用于那些一次性渲染，并且不会再有操作更改这些渲染的值，这样就可以优化双向绑定的更新性能。</p><h3 id="文档推荐：对低开销的静态组件使用-v-once"><a href="#文档推荐：对低开销的静态组件使用-v-once" class="headerlink" title="文档推荐：对低开销的静态组件使用 v-once"></a><a href="https://cn.vuejs.org/v2/guide/components.html#对低开销的静态组件使用-v-once" target="_blank" rel="external">文档</a>推荐：对低开销的静态组件使用 v-once</h3><p>尽管在 Vue 中渲染 HTML 很快，不过当组件中包含大量静态内容时，可以考虑使用 v-once 将渲染结果缓存起来，就像这样：</p><pre><code>Vue.component(&apos;terms-of-service&apos;, {  template: &apos;\    &lt;div v-once&gt;\      &lt;h1&gt;Terms of Service&lt;/h1&gt;\      ...很多静态内容...\    &lt;/div&gt;\  &apos;})</code></pre><h2 id="vue风格指南推荐："><a href="#vue风格指南推荐：" class="headerlink" title="vue风格指南推荐："></a>vue风格指南推荐：</h2><p>写到这里想到vue框架还有一个<a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="external">风格指南</a>推荐，如下图所示，大家也可以学习一波。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/17/160fff0ec0147156?w=1578&amp;h=811&amp;f=png&amp;s=174542" alt="vue风格指南"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>上面就是我分享的几个小问题，希望大家看了能够有所收获！另：明年准备去上海，如果小伙伴的公司有坑，可以联系一下我。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><strong><a href="http://obkoro1.com/" target="_blank" rel="external">个人blog</a></strong> and <strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a></strong>  </p><p>以上2018.1.17</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇是我在使用vue过程中，遇到的几个小问题和之前不了解的东西，记录下来，希望能够帮助各位踩坑。如果喜欢的话可以点波赞，或者关注一下，希望本
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="实践" scheme="http://yoursite.com/tags/%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="Vue-router" scheme="http://yoursite.com/tags/Vue-router/"/>
    
      <category term="定时器" scheme="http://yoursite.com/tags/%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>【读书笔记】《高性能JavaScript》</title>
    <link href="http://yoursite.com/2018/01/09/%E3%80%90%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E3%80%91%E3%80%8A%E9%AB%98%E6%80%A7%E8%83%BDJavaScript%E3%80%8B/"/>
    <id>http://yoursite.com/2018/01/09/【读书笔记】《高性能JavaScript》/</id>
    <published>2018-01-09T08:07:25.000Z</published>
    <updated>2018-01-09T08:56:49.434Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>这本书是2010年出版的，这本书谈性能是有时效性的，现在马上就2018年了，这几年前端发展的速度是飞快的，书里面还有一些内容考虑IE6、7、8的东西，殊不知现在这些都已经不再考虑了，所以不可避免的有一些知识是比较老的。有些解决方法现在已经不是最好的解决方式，比如工具那一章。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>总的来说，这本书整体给出的性能优化建议，以及作者耐心的实践，对我们开发优化的启发和帮助还是很大的</strong>，因为它里边的很多知识，都是作者通过实践总结出来的，都是经验的积累，这在一般的教科书上是学不到的。特别是对于js基础比较差一点的，里面有很多知识点尽管在现在还是非常有必要的。</p><p><strong>下面我就将各章节的一些重要的知识点总结写出来，争取将干货都提取出来</strong>。</p><blockquote><p>本文首发于我的个人blog：<a href="http://obkoro1.com/" target="_blank" rel="external">obkoro1.com</a></p></blockquote><hr><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p><img src="https://user-gold-cdn.xitu.io/2017/12/31/160ac466f78b83d3?w=600&amp;h=784&amp;f=jpeg&amp;s=53979" alt=" 封面 "></p><h3 id="第一章-加载和执行"><a href="#第一章-加载和执行" class="headerlink" title="第一章-加载和执行"></a>第一章-加载和执行</h3><ol><li>js的阻塞特性：</li></ol><p>当浏览器在执行js代码的时候，不能同时做其他事情。（界面ui线程和js线程用的是同一进程，所以js执行越久，网页的响应时间越长。）</p><ol><li>脚本的位置</li></ol><p><strong>如果把脚本<code>&lt;script&gt;</code>放在<code>&lt;head&gt;</code>中，页面会等js文件全部下载并执行完成后才开始渲染</strong>，在这些文件下载和执行的过程中：会导致访问网站的时候有明显的延迟，表现为：页面空白。</p><p> 性能提升：<strong>推荐将所有的<code>&lt;script&gt;</code>标签尽可能的放到<code>&lt;body&gt;</code>标签的底部</strong>，优先渲染页面，减少页面空白时间。</p><ol><li>组件脚本。</li></ol><p>每个<code>&lt;script&gt;</code>标签初始下载的时候都会阻塞页面的渲染。性能提升做法：<br><strong>减少内嵌脚本：减少内嵌的<code>&lt;script&gt;</code>标签</strong>，将代码写在一个标签中。</p><p><strong>合并外链的js文件</strong>：http请求会带来额外的性能开销，栗子：下载一个100KB的js文件比下载4个25kb的js文件更快。具体操作方法自行搜索。</p><ol><li>无阻塞脚本的方法</li></ol><p><strong>script标签的aync属性</strong>：</p><p>async 属性规定一旦脚本可用，则会异步执行。async 属性仅适用于外部脚本（只有在使用 src 属性时）。如果 async=”async”：脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行）</p><p><strong>script标签的defer属性</strong>：</p><p>js文件在页面解析到script标签的时候开始下载，但并不会执行，dom加载完成执行。<strong>这两个属性的区别在于执行时机</strong>。</p><p><strong>动态脚本元素</strong>。</p><p>js操作dom创建<code>&lt;script&gt;</code>标签，自定义生成标签的type、src属性。文件会在该元素被添加到页面的时候开始下载。ps：如果文件顺序很重要的话，最好按照顺序合成一个文件。然后再添加到页面中。这样：无论何时启动下载。文件的下载和执行过程不会阻塞页面的其他进程。</p><h5 id="3-XHR-ajax脚本注入、"><a href="#3-XHR-ajax脚本注入、" class="headerlink" title="3. XHR ajax脚本注入、"></a>3. XHR ajax脚本注入、</h5><p>用get请求一个文件，请求好了。然后创建动态脚本，最后添加进去。<br>缺陷：文件要再请求页面的同一个域。不能从cdn下载</p><h3 id="第一章加载和执行小结："><a href="#第一章加载和执行小结：" class="headerlink" title="第一章加载和执行小结："></a>第一章加载和执行小结：</h3><ol><li>把文件放在body标签签名，</li><li>合并脚本，减少<code>&lt;script&gt;</code>标签。</li><li>采用无阻塞下载js。使用script的defer和async属性 异步下载。动态创建script标签和执行代码。</li></ol><h3 id="第二章-数据存取"><a href="#第二章-数据存取" class="headerlink" title="第二章-数据存取"></a>第二章-数据存取</h3><ol><li><strong>js四种基本的数据存取位置</strong>。<br>1、字面量：字符串、数字、布尔、对象、数组、函数、正则、null、undefined，字面量只代表自身，没有存储位置。 2、局部变量。 let var 声明的变量。3、数组元素。4、对象成员。</li></ol><p>性能：<strong>访问字面量和局部变量的速度是最快的，访问数组和对象成员相对较慢</strong></p><ol><li><strong>变量标识符解析过程</strong>：</li></ol><p>搜索执行环境的作用域链，查找同名标识符。搜索过程从作用域链头部开始，也就是当前运行函数的活动对象。如果找到，就使用这个标识符，对应的变量；如果没有找到，继续搜索下面的对象。搜索过程会持续进行，直到找到标识符，若无法搜索到匹配的对象，那么标识符被视为未定义、</p><p><strong>性能问题：一个标识符所在的位置越深，它的读写速度也就越慢</strong>。因此，函数中读写局部变量总是最快的，而读写全局变量通常是最慢的。</p><p><strong>建议：将全局变量存储到局部变量，加快读写速度。</strong></p><ol><li>闭包，原型，嵌套对象。</li></ol><p><strong>优化建议：将常用的跨作用域变量存储到局部变量，然后直接访问局部变量</strong>。理由如上，变量标识符解析过程。</p><h3 id="第二章数据存取小结："><a href="#第二章数据存取小结：" class="headerlink" title="第二章数据存取小结："></a>第二章数据存取小结：</h3><ol><li>访问字面量和局部变量的速度最快，相反，访问数组元素和对象成员相对较慢。</li><li>由于局部变量存在于作用域链的起始位置，因为<strong>访问局部变量比访问跨作用域变量更快。这个道理同样适用于数组，对象，跨作用域变量</strong>。</li><li>把常用的对象，数组，跨域变量保存在局部变量可以改善js性能，局部变量访问速度更快。</li></ol><h3 id="第三章DOM编程小结："><a href="#第三章DOM编程小结：" class="headerlink" title="第三章DOM编程小结："></a>第三章DOM编程小结：</h3><ol><li><strong>dom操作天生就慢，尽量减少dom操作</strong>，减少访问dom的次数。</li><li>使用document.querySelect来做选择器，比其他方式快。</li><li>需要多次访问某个dom节点，使用局部变量存储。</li><li>html集合，把集合长度缓存到一个变量中，然后遍历使用这个变量，如果经常操作集合，建议拷到一个数组中。</li><li>要留意浏览器的重绘和重排；批量修改样式的时候，‘离线’操作DOM树，使用缓存，并减少访问布局信息的次数。<br>重绘和重排是DOM编程优化的一个相当重要概念：<a href="http://web.jobbole.com/83164/" target="_blank" rel="external">重绘和重排</a>。</li><li>动画中使用绝对定义，使用拖放处理。</li><li>使用事件委托来减少事件处理器的数量。</li></ol><h3 id="第四章算法和流程控制小结："><a href="#第四章算法和流程控制小结：" class="headerlink" title="第四章算法和流程控制小结："></a>第四章算法和流程控制小结：</h3><ol><li><p>for、while和do-while循环性能差不多，<strong>for-in循环速度只有前面几种类型的1/7</strong>，所以尽量避免使用for-in循环，除非你需要遍历一个属性数量未知的对象。</p><p> forEach比for慢，如果运行速度要求严格，不建议使用。</p></li><li><p>改善循环性能的最佳方式是<strong>减少每次迭代的工作量和减少循环迭代的次数</strong>。</p></li></ol><p>减少迭代工作量：减少属性查找和倒序循环，循环次数越多，性能优化越明显。</p><pre><code>for(var i=0;i&lt;items.length;i++){代码}//正序循环for(var i=items.length;i--){代码}//倒序循环//减少属性查找：查找一次属性，把值存在局部变量，在控制条件里面使用这个变量倒序循环在i&gt;0的时候会自动转换为true，等于0的时候为false。//倒序循环：控制条件从（迭代数少于总数吗？它是否为true？）变为（它是否为true）</code></pre><p>减少迭代的次数：”Duff’s Device”循环体展开技术，有兴趣的可以看一下，迭代工作量大于1000的时候适用。</p><ol><li><p>if-else与switch：条件数量越大，越倾向于使用switch。</p><p> 优化if-else：</p><pre><code>1、把最可能出现的条件放在首位。2、使用二分法把值域分成一系列的区间。</code></pre></li><li><p>浏览器的调用栈大小限制了递归算法在js中的应用；栈溢出错误会导致其他代码中断运行。</p><pre><code>小心使用递归，现在es6递归可以尾递归，在es6中只要使用尾递归就不会发生栈溢出，相对节省性能。</code></pre></li></ol><h3 id="第五章字符串和正则表达式小结："><a href="#第五章字符串和正则表达式小结：" class="headerlink" title="第五章字符串和正则表达式小结："></a>第五章字符串和正则表达式小结：</h3><ol><li><p>字符串合并的时候使用简单的’+’和’+=’操作符。</p><pre><code>str+=&apos;abc&apos;+&apos;efg;//2个以上的字符串拼接，会产生临时字符串str=str+&apos;abc&apos;+&apos;efg&apos;;//推荐，提速10%~40%  </code></pre></li><li><p>书里面讲的<strong>正则原理和回溯原理，这个很重要</strong>，找个篇<a href="http://blog.csdn.net/c_kite/article/details/77875328" target="_blank" rel="external">博客</a>：跟书里面讲的差不多，但还是建议大家可以去找找PDF好好看看正则表达式这节。</p></li><li><p>提高正则表达式效率的方法：</p><pre><code>1、最重要的是：具体化正则表达式！具体化正则表达式！具体化正则表达式！2、关注如何让匹配更快失败，找出一些必需，特殊的字符3、正则表达式以简单的、必需的字元开始。4、使用量词模式，使它们后面的字元互斥。5、较少分支数量，缩小分支范围6、使用合适的量词7、把正则表达式赋值给变量并重用8、将复杂的正则拆分为简单的片段//事实上，书里面讲的方法不止这么几个，而且每一个都有详细的解析 大佬们 还是去看看这一章节吧</code></pre></li><li><p>正则表达式并不总是最好的解决方案，当你只是搜索字面字符串或者你事先知道字符串的哪一部分将要被查找时：</p><pre><code>使用indexOf()和lastIndexOf()更适合查找特定字符串的位置或者判断它们是否存在//例如：判断当前浏览器之类。</code></pre></li></ol><h3 id="第六章快速响应的用户界面小结："><a href="#第六章快速响应的用户界面小结：" class="headerlink" title="第六章快速响应的用户界面小结："></a>第六章快速响应的用户界面小结：</h3><p>js和用户界面更新在同一个进程中运行，因此一次只能处理一件事情。高效的管理UI线程就是要确保js不能运行太长时间，以免影响用户体验。</p><ol><li><p>浏览器限制了js任务的运行时间，这种限制很有必要，它确保某些恶意代码不能通过永不停止的密集操作锁住用户的浏览器。此限制分为两种：调用栈的大小和长时间运行脚本。</p></li><li><p>任何js任务都不应当执行超过100毫秒。过长的运行时间会导致UI更新出现明显延迟，从而对用户体验造成负面影响。 </p></li><li><p>定时器可用来安排代码延迟执行，它使得你可以把长时间运行脚本分解成一系列的小任务。</p></li></ol><h3 id="第七章-AJAX-小结"><a href="#第七章-AJAX-小结" class="headerlink" title="第七章 AJAX 小结"></a>第七章 AJAX 小结</h3><p>这一章节貌似东西都比较老一点。。</p><ol><li>post更适合发送大量数据到服务器。</li><li><p>get请求能够被浏览器缓存，Expires头信息设置浏览器缓存请求多久。可用于从不改变的图片或者其他静态数据集（js、css等）</p></li><li><p>JSON是一种使用js对象和数组直接量编写的轻量级且易于解析的数据格式，它不仅传输尺寸小，而且解析速度快。JSON是高性能AJAX的基础，尤其在使用动态脚本注入时。</p></li></ol><p>json应该是近几年一直在用的。。。</p><ol><li>减少请求数，通过合并js和css文件。</li><li>缩短页面的加载时间，页面主要内容加载完成后，用AJAX获取那些次要的文件。</li></ol><h3 id="第八章编程实践小结"><a href="#第八章编程实践小结" class="headerlink" title="第八章编程实践小结"></a>第八章编程实践小结</h3><ol><li><p>避免双重求值：避免使用eval()和 function()构造器来避免双重求值带来的性能消耗，同样的，给setTimeout()和setInterval()传递函数而不是字符串作为参数。</p><pre><code>//双重求值：就是在js代码中执行另一段js代码，不建议使用下面这些方式eval(&apos;代码&apos;) function构造函数--new function(&apos;代码&apos;)setTimeout(‘代码’,100)和setInterval(‘代码’,100) </code></pre></li><li>尽量使用直接量创建对象和数组。直接量的创建和初始化都比非直接量形式要快。</li><li>避免做重复工作，能节省的步骤就节省。</li><li>js原生方法总会比你写的任何代码都要快。</li></ol><h3 id="第九章-构建并部署高性能js应用小结"><a href="#第九章-构建并部署高性能js应用小结" class="headerlink" title="第九章 构建并部署高性能js应用小结"></a>第九章 构建并部署高性能js应用小结</h3><p>构建和部署的过程对基于js的web应用的性能有着巨大影响。这个过程中最重要的步骤有：</p><ol><li>合并、压缩js文件。<strong>可使用Gzip压缩，能够减少约70%的体积</strong>！</li></ol><p>这些都是在构建过程中完成的工作，不要等到运行时去做，webpack也是在构建过程中，完成的工作。</p><ol><li>通过正确设置HTTP响应头来缓存js文件，通过向文件名增加时间戳来避免缓存问题。</li><li>使用CDN提供js文件；CDN不仅可以提升性能，它也为你管理文件的压缩与缓存，。</li></ol><h3 id="第十章-工具-小结："><a href="#第十章-工具-小结：" class="headerlink" title="第十章 工具 小结："></a>第十章 工具 小结：</h3><p>当网页变慢时，分析从网络下载的资源以及分析的资源以及分析脚本的运行性能能让你专注于那些最需要优化的地方。</p><ol><li><p>使用网络分析工具找出加载脚本和页面中其他资源的瓶颈，这会帮助你决定那些脚本需要延迟加载，或者需要进一步分析。</p><pre><code>检查图片、样式表和脚本的加载过程，以及它们对页面整体加载和渲染的影响。从而针对性的做出优化</code></pre></li><li>把脚本尽可能延迟加载，这样做可以加快页面渲染速度，给用户带来更好的体验。</li><li><p>确认脚本和其他资源文件的加载过程已经被优化</p><pre><code>这里主要是说文件从服务器的下载速度，比如服务器那边的配置问题之类的。栗子：我就被后端坑过。一个js文件就200k ，下载下来需要50秒钟！后面发现原来是后端那边nginx没有开启加速配置什么的，导致出现的问题，找问题找半天。 </code></pre></li><li><p>测试脚本的运行时间,用一个Date实例减去另一个Date实例，得到的时间差就是脚本运行消耗的时间。</p><pre><code>let start=new Date();//你的代码let time=newDate()-start;</code></pre></li><li><p><strong>chrome ,火狐 等主流浏览器的控制面板，已经能够反映很多性能问题</strong>。仔细分析就能找出很多问题。例如：资源加载，断点等</p></li></ol><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>事实上，<strong>自认为这本书最宝贵的就是一些提到的细节</strong>，比如：</p><p>1、字符串合并的时候使用简单的’+’和’+=’操作符。</p><pre><code>str+=&apos;abc&apos;+&apos;efg;//2个以上的字符串拼接，会产生临时字符串str=str+&apos;abc&apos;+&apos;efg&apos;;//推荐，提速10%~40%</code></pre><p>2、避免双重求值：避免使用eval()和 function()构造器来避免双重求值带来的性能消耗，同样的，给setTimeout()和setInterval()传递函数而不是字符串作为参数。</p><pre><code>//双重求值：就是在js代码中执行另一段js代码，不建议使用下面这些方式eval(&apos;代码&apos;) function构造函数--new function(&apos;代码&apos;)setTimeout(‘代码’,100)和setInterval(‘代码’,100) </code></pre><h3 id="这些东西可以让我们知道什么是更好的实践，什么样的代码可以跑得更快，让我们养成更好的开发习惯。"><a href="#这些东西可以让我们知道什么是更好的实践，什么样的代码可以跑得更快，让我们养成更好的开发习惯。" class="headerlink" title="这些东西可以让我们知道什么是更好的实践，什么样的代码可以跑得更快，让我们养成更好的开发习惯。"></a>这些东西可以让我们知道什么是更好的实践，什么样的代码可以跑得更快，让我们养成更好的开发习惯。</h3><p>书不太厚，如果对里面的内容感兴趣，还是建议买一本回家看一看。</p><p>以上2017.1.9</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;缺陷&quot;&gt;&lt;a href=&quot;#缺陷&quot; class=&quot;headerlink&quot; title=&quot;缺陷&quot;&gt;&lt;/a&gt;缺陷&lt;/h3&gt;&lt;p&gt;这本书是2010年出版的，这本书谈性能是有时效性的，现在马上就2018年了，这几年前端发展的速度是飞快的，书里面还有一些内容考虑IE6、7、
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="性能" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>js 简单的推箱子小游戏步骤解析--大家都玩过的</title>
    <link href="http://yoursite.com/2018/01/07/js-%E7%AE%80%E5%8D%95%E7%9A%84%E6%8E%A8%E7%AE%B1%E5%AD%90%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%AD%A5%E9%AA%A4%E8%A7%A3%E6%9E%90-%E5%A4%A7%E5%AE%B6%E9%83%BD%E7%8E%A9%E8%BF%87%E7%9A%84/"/>
    <id>http://yoursite.com/2018/01/07/js-简单的推箱子小游戏步骤解析-大家都玩过的/</id>
    <published>2018-01-07T15:45:15.000Z</published>
    <updated>2018-01-07T16:03:18.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>推箱子小游戏大家肯定都玩过，之所以写这篇文章，是觉得这个小游戏足够简单好理解，大家看完文章之后，自己也能花上半天功夫敲出一个推箱子小游戏来，如果喜欢的话可以点波赞，或者关注一下，希望本文可以帮到大家。</p><blockquote><p>本文首发于我的个人blog：<a href="http://obkoro1.com/" target="_blank" rel="external">obkoro1.com</a></p></blockquote><h3 id="demo：推箱子小游戏"><a href="#demo：推箱子小游戏" class="headerlink" title="demo：推箱子小游戏"></a>demo：<a href="http://obkoro1.com/simpleDemo/pushKoro/index.html" target="_blank" rel="external">推箱子小游戏</a></h3><p><img src="https://user-gold-cdn.xitu.io/2018/1/8/160d15a420195ea4?w=611&amp;h=529&amp;f=png&amp;s=8760" alt="推箱子"></p><h2 id="步骤解析："><a href="#步骤解析：" class="headerlink" title="步骤解析："></a>步骤解析：</h2><p><strong>本文代码已经放在了<a href="https://github.com/OBKoro1/simpleDemo/tree/master/pushKoro" target="_blank" rel="external">github</a>上面了,里面也进行了很详细的代码注释，可以copy下来，在本地运行一下看看</strong>。</p><h3 id="1-渲染地图"><a href="#1-渲染地图" class="headerlink" title="1. 渲染地图"></a>1. 渲染地图</h3><ol><li><p>html结构：<br><img src="https://user-gold-cdn.xitu.io/2018/1/7/160d1149856a3714?w=503&amp;h=727&amp;f=png&amp;s=48024" alt=""></p><pre><code>html结构十分简单，只要弄一堆div，来放置地图的class就可以了，我这里初始化了12*9个div，地图里最多九行高度。   这些div都是同样大小，地图渲染出来区别的只是颜色的不同。</code></pre><ol><li><p>地图函数：</p><p>  var box=$(‘.box div’); //地图使用的div集合<br>  function create(){ //创建地图函数<br>  box.each(function(index){ //index的数量是固定的，是box div下面div的数量</p><pre><code> // 每次创建地图初始化divbox.eq(index).removeClass();</code></pre><p>  });<br>  box.each(function(index,element){ //循环整个div的数量 二维数组里数量不够的 默认为空白<br>  //level为关卡数 根据关卡渲染地图 builder为二维数组，为地图关卡</p><pre><code>if(builder[level][index]){ //过滤0    box.eq(index).addClass(&apos;type&apos;+builder[level][index]);}</code></pre><p>  });<br>  box.eq(origin[level]).addClass(“pusher”); //推箱人 皮卡丘位置<br>  }</p><p>  //第一关的地图长这样（下面只是栗子，不是代码），0代表不可抵达区域，1代表目标（要被推到的地方），<br>  //2代表普通路径（可以走的），3代表墙，4代表箱子<br>  [0,0,0,0,3,3,3,0,0,0,0,0,<br>  0,0,0,0,3,1,3,0,0,0,0,0,<br>  0,0,0,0,3,2,3,3,3,3,0,0,<br>  0,0,3,3,3,4,2,4,1,3,0,0,<br>  0,0,3,1,2,4,2,3,3,3,0,0,<br>  0,0,3,3,3,3,4,3,0,0,0,0,<br>  0,0,0,0,0,3,1,3,0,0,0,0,<br>  0,0,0,0,0,3,3,3,0,0,0,0] </p></li></ol></li></ol><h3 id="2-捕获键盘事件-判断是否可以移动"><a href="#2-捕获键盘事件-判断是否可以移动" class="headerlink" title="2. 捕获键盘事件,判断是否可以移动"></a>2. 捕获键盘事件,判断是否可以移动</h3><p>使用<a href="http://www.w3school.com.cn/jquery/event_keydown.asp" target="_blank" rel="external">$(document).keydown()</a>jqery事件，捕获键盘事件。</p><ol><li><p>捕获键盘事件，上下左右以及wsad。 </p><pre><code>$(document).keydown(function (e) { var key=e.which; switch(key){ //col 的值为12，上下移动要12个div为一个周期 //方向键上或者w case 87: case 38:     move(-col);//判断移动函数 break; //方向键下或者s case 83: case 40:    move(col); break; //方向键左或者a case 65: case 37:     move(-1); break; //方向键右或者d case 68: case 39:     move(1); break; }setTimeout(win,500); //按键之后调判断是否过关});</code></pre></li><li><p>判断是否可以移动。</p></li></ol><p>分为两个判断条件：一个是推箱子，一个是不推箱子 自然移动，否则不移动皮卡丘。</p><pre><code>function move(step){ //是否移动判断     // 分为两个判断条件一个是推箱子，一个是不推箱子 自然移动。 否则不移动皮卡丘     //step 上下是12个div一个周期，左右是1个div positin是皮卡丘的原来位置    var pikaqiu1=box.eq(position);//皮卡丘现在的地方    var pikaqiu2=box.eq(position+step);//皮卡丘要去的下一个地方    var pushBox=box.eq(position+step*2);//箱子要去的下一个地方    if(!pikaqiu2.hasClass(&apos;type4&apos;)&amp;&amp;( pikaqiu2.hasClass(&apos;type1&apos;)||pikaqiu2.hasClass(&apos;type2&apos;))){ //自然移动        //判断：如果下一个div的class不包含type4(箱子)，并且 下一个div含有type1(目标位置)，或者type2(普通路径)        //这一步和下一步判断是否有type4的原因是普通路径会变成有type4的路径，这时候就会出现问题        pikaqiu1.removeClass(&quot;pusher&quot;); //移除当前皮卡丘        pikaqiu2.addClass(&quot;pusher&quot;);//移动皮卡丘到下一个位置        position=position+step;//增加position值    }    else if((pikaqiu2.hasClass(&apos;type4&apos;))&amp;&amp;(!pushBox.hasClass(&apos;type4&apos;))&amp;&amp;(pushBox.hasClass(&apos;type1&apos;)|| pushBox.hasClass(&apos;type2&apos;)) ) {        //推箱子            //如果下一个div的class包含type4(箱子)并且 不包含重叠type4(箱子) 并且 包含class type1（目标位置）或者 包含type2(空路)       pikaqiu2.removeClass(&apos;type4&apos;);//移除当前箱子        pikaqiu1.removeClass(&quot;pusher&quot;);//移除当前皮卡丘        pushBox.addClass(&apos;type4&apos;);//移动箱子到下一个位置        pikaqiu2.addClass(&quot;pusher&quot;).addClass(&quot;type2&quot;);//        //本来是type4 移除之后，这里没有class了，要变成普通路径        position=position+step;//增加position值     }}    </code></pre><h3 id="3-胜利判断："><a href="#3-胜利判断：" class="headerlink" title="3.胜利判断："></a>3.胜利判断：</h3><p>每次移动都要调用这个胜利判断。</p><pre><code>function win(){ //胜利条件判断    if($(&quot;.type1.type4&quot;).length===goal){ //推的箱子与关卡设置通过箱子的数量对比        if(level&lt;9) {            alert(&quot;666，挑战下一关吧--OBKoro1&quot;);            level++; //关卡+1            goal = goalList[level];            position = origin[level];            create();        }else {            alert(&quot;厉害啊 大佬 通关了都&quot;);        }    }}</code></pre><h3 id="代码地址、demo地址"><a href="#代码地址、demo地址" class="headerlink" title="代码地址、demo地址"></a><a href="https://github.com/OBKoro1/simpleDemo/tree/master/pushKoro" target="_blank" rel="external">代码地址</a>、<a href="http://obkoro1.com/simpleDemo/pushKoro/index.html" target="_blank" rel="external">demo地址</a></h3><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文到这里就结束了，喜欢的话，赶紧自己去敲一个出来，希望本文可以帮助大家发散思维。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><strong><a href="http://obkoro1.com/" target="_blank" rel="external">个人blog</a></strong> and <strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a></strong>  </p><p>以上2018.1.7</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;推箱子小游戏大家肯定都玩过，之所以写这篇文章，是觉得这个小游戏足够简单好理解，大家看完文章之后，自己也能花上半天功夫敲出一个推箱子小游戏来，
      
    
    </summary>
    
      <category term="小demo" scheme="http://yoursite.com/categories/%E5%B0%8Fdemo/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="jq" scheme="http://yoursite.com/tags/jq/"/>
    
      <category term="小demo" scheme="http://yoursite.com/tags/%E5%B0%8Fdemo/"/>
    
      <category term="H5小游戏" scheme="http://yoursite.com/tags/H5%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>vue先hash 模式部署项目，然后开启histroy模式 ，引发的几个问题以及histroy模式的开启方式、优点</title>
    <link href="http://yoursite.com/2017/12/25/vue%E5%85%88hash-%E6%A8%A1%E5%BC%8F%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%EF%BC%8C%E7%84%B6%E5%90%8E%E5%BC%80%E5%90%AFhistroy%E6%A8%A1%E5%BC%8F-%EF%BC%8C%E5%BC%95%E5%8F%91%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8Ahistroy%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BC%80%E5%90%AF%E6%96%B9%E5%BC%8F%E3%80%81%E4%BC%98%E7%82%B9/"/>
    <id>http://yoursite.com/2017/12/25/vue先hash-模式部署项目，然后开启histroy模式-，引发的几个问题以及histroy模式的开启方式、优点/</id>
    <published>2017-12-24T16:48:11.000Z</published>
    <updated>2017-12-31T11:43:41.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>vue路由有一个<a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="external">HTML5 History 模式</a>,这个模式要在路由里面另外开启的，很多人在刚使用路由的时候之前不知道这个模式，所以并没有启用，然后就把项目部署上去了，因为这个模式还是有挺多优点的，最后还是会开启这个模式。</p><p>然而因为<strong>之前使用hash模式再改为histroy模式还是有些问题的</strong>，我已经踩过坑了，然后把这几个问题写出来。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。</p><blockquote><p>本文首发于我的个人blog：<a href="http://obkoro1.com/" target="_blank" rel="external">obkoro1.com</a></p></blockquote><h3 id="开启history模式："><a href="#开启history模式：" class="headerlink" title="开启history模式："></a>开启history模式：</h3><p>如果不开启的话，路由默认是hash模式，开启这个模式前端的工作也很简单，如下：</p><pre><code>mode: &apos;history&apos; //在路由那里配置一下这个</code></pre><p>最后需要后端的做一些配置配合，这里可以参考一下文档给的<a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="external">栗子</a>。</p><h2 id="history模式的优点"><a href="#history模式的优点" class="headerlink" title="history模式的优点:"></a>history模式的优点:</h2><ol><li><p>url变成真正的url，url看上去更好看。</p><pre><code>http://yoursite.com/#/a/b  //hash模式http://yoursite.com/a/b  //history模式</code></pre></li><li><p>可以使用vue-router的<a href="https://router.vuejs.org/zh-cn/advanced/scroll-behavior.html" target="_blank" rel="external">滚动行为</a>，这个用来记忆进入其他页面之前的位置非常好用，配置一下就可以直接使用了，前提是开启histroy模式。<br><img src="https://user-gold-cdn.xitu.io/2017/12/24/160885359af4ff1e?w=1062&amp;h=271&amp;f=png&amp;s=35110" alt=""></p></li><li><p>类似<a href="http://obkoro1.com/2017/12/16/vue-%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E5%BC%95%E5%85%A5%E5%BE%AE%E4%BF%A1sdk%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB%E6%8E%A5%E5%8F%A3/" target="_blank" rel="external">项目引入微信js-sdk</a>的时候，一些操作是对url是有要求，url不能带上’#’，如果没有开启histroy模式，很可能会导致问题。</p></li><li><p>像vue-cli的配置，都是以路由开启history模式的标准来配置的（下面会讲到一个栗子），没有开启的话，自己要另外配置。</p></li></ol><h2 id="先hash模式，后histroy模式"><a href="#先hash模式，后histroy模式" class="headerlink" title="先hash模式，后histroy模式"></a>先hash模式，后histroy模式</h2><p>就像开头说的，这里的问题指的是：<strong>先用hash模式部署项目到线上，然后再开启histroy模式</strong>，由此引发的一些问题。</p><h3 id="1-找不到资源问题："><a href="#1-找不到资源问题：" class="headerlink" title="1.找不到资源问题："></a>1.找不到资源问题：</h3><p><strong>在hash模式下面，直接打包的话，会导致找不到css、js和图片资源</strong>，然后经过百度之后，做出了如下截图的配置操作，更改<code>assetsPublicPath：&#39;/&#39;</code>为 <code>assetsPublicPath：&#39;./&#39;</code></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/24/16088625b417b4ac?w=872&amp;h=382&amp;f=png&amp;s=43320" alt=""></p><p>在hash模式下，像上面那么配置就没有问题了。当时我还以为vue-cli配置有问题，实际上，人家才没有问题呢，是我们自己没有开启history模式的问题。</p><p>然后开启了histroy模式之后，因为我们之前更改了assetsPublicPath属性，所以要把那个<code>.</code>给去掉，改回来：<code>assetsPublicPath：&#39;/&#39;</code></p><h3 id="2-请求带上路由，导致请求失败"><a href="#2-请求带上路由，导致请求失败" class="headerlink" title="2.请求带上路由，导致请求失败"></a>2.请求带上路由，导致请求失败</h3><h4 id="正确的请求是："><a href="#正确的请求是：" class="headerlink" title="正确的请求是："></a>正确的请求是：</h4><pre><code>http:www.xxx.com/api/接口 //api是我通过proxyTable转发地址的代理名字</code></pre><h4 id="开启histroy模式之后："><a href="#开启histroy模式之后：" class="headerlink" title="开启histroy模式之后："></a>开启histroy模式之后：</h4><p>在二层的路由里面会出现这种情况：</p><pre><code>路由是：http:www.xxx.com/a/bhttp:www.xxx.com/api/a/接口 //这就导致了请求失败，要把a也去掉才是正确的</code></pre><p>解决方式是：</p><p>因为我用的是<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="external">axios</a>，所以可以在<a href="https://juejin.im/post/59fd982c6fb9a045170490df" target="_blank" rel="external">全局请求</a>中设置一个baseURL，这个baseURL就是项目的网站地址（http:www.xxx.com）,然后二层的路由也会自动去掉前面的a和b。</p><h3 id="3-cookie问题"><a href="#3-cookie问题" class="headerlink" title="3.cookie问题"></a>3.cookie问题</h3><p>这个实际上不是个问题，完全是自己作的，<strong>我把项目分为两层。所以从a登录，b那边刷新就会出现没有cookie的情况</strong>。</p><pre><code>两层路由http://yoursite.com/ahttp://yoursite.com/b</code></pre><p>这里是因为cookie能否拿到跟存储的路由位置是有关的，之前使用hash模式因为hash模式的url<code>http://yoursite.com/#/a/b</code>，会统一存在<a href="http://yoursite.com下面。" target="_blank" rel="external">http://yoursite.com下面。</a></p><p>而history模式cookie就会存在<code>http://yoursite.com/a</code>或者<code>http://yoursite.com/b</code>下面，另外一边就会没有cookiie。</p><h4 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h4><ol><li>不要分为两层，统一所有的路由都在一个路由地址下面。</li><li>在项目的路由的根地址<code>path:&#39;/&#39;</code>里面存cookie。</li><li><p>使用sessionStorage存信息，我就是用这个方法，<a href="http://obkoro1.com/2017/11/25/cookie%E3%80%81localStorage%E5%92%8CsessionStorage%20%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%82%A8%E3%80%81%E8%8E%B7%E5%8F%96%E3%80%81%E5%88%A0%E9%99%A4%E7%AD%89%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/" target="_blank" rel="external">使用方法</a>。</p><p>  sessionStorage只要在<a href="http://yoursite.com都可以访问的到，不管是存在a上面还是b上面。" target="_blank" rel="external">http://yoursite.com都可以访问的到，不管是存在a上面还是b上面。</a></p></li></ol><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>以上就是本文的所有内容，建议项目一开始还是直接跟后端说一下，开启histroy模式，省得后面的种种坑。上面的内容都是本人亲自踩坑之后的血泪教训，希望可以帮助到需要的朋友，然后祝大家圣诞节快乐。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><strong><a href="http://obkoro1.com/" target="_blank" rel="external">个人blog</a></strong> and <strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a></strong>  </p><p>以上2017.12.25</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h2&gt;&lt;p&gt;vue路由有一个&lt;a href=&quot;https://router.vuejs.org/zh-cn/essentials/history
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="Vue-router" scheme="http://yoursite.com/tags/Vue-router/"/>
    
      <category term="Vue-cli" scheme="http://yoursite.com/tags/Vue-cli/"/>
    
  </entry>
  
  <entry>
    <title>vue 项目如何引入微信sdk，使用微信分享接口</title>
    <link href="http://yoursite.com/2017/12/16/vue-%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E5%BC%95%E5%85%A5%E5%BE%AE%E4%BF%A1sdk%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%AB%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2017/12/16/vue-项目如何引入微信sdk，使用微信分享接口/</id>
    <published>2017-12-16T12:46:14.000Z</published>
    <updated>2017-12-16T12:47:24.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>做微信的网页基本上都要接入微信的sdk，我在做的时候，也颇费了一番功夫，然后就想记录一下，供自己日后翻阅，以及让有需要的朋友可以做一下参考，如果喜欢的可以点波赞，或者关注一下，希望可以帮到大家。</p><blockquote><p>本文首发于我的个人blog：<a href="http://obkoro1.com/" target="_blank" rel="external">obkoro1.com</a></p></blockquote><h3 id="安装sdk"><a href="#安装sdk" class="headerlink" title="安装sdk"></a>安装sdk</h3><pre><code>npm install weixin-js-sdk --save</code></pre><p>开始之前大家可以先读一读微信公众号的 <strong><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115" target="_blank" rel="external">接入文档</a></strong>，vue是单页面项目，比如你想要接入微信分享功能，分享功能在每个路由地址都要有，因为每个路由的url是不一样的，搜易就需要在每个路由地址都引入一遍。</p><h2 id="整体步骤："><a href="#整体步骤：" class="headerlink" title="整体步骤："></a>整体步骤：</h2><ol><li>vue引入sdk的话，就是在路由组件里面的，组件生命周期的：creatd()和mounted()里面放代码。</li><li><p>用伪代码，熟悉一下整体的流程，要做哪些事情：</p><pre><code>//wx是引入的微信sdkwx.config(&apos;这里有一些参数&apos;);//通过config接口注入权限验证配置wx.ready(function() { //通过ready接口处理成功验证// config信息验证成功后会执行ready方法    wx.onMenuShareAppMessage({ // 分享给朋友  ,在config里面填写需要使用的JS接口列表，然后这个方法才可以用         title: &apos;这里是标题&apos;, // 分享标题        desc: &apos;This is a test!&apos;, // 分享描述        link: &apos;链接&apos;, // 分享链接        imgUrl: &apos;图片&apos;, // 分享图标        type: &apos;&apos;, // 分享类型,music、video或link，不填默认为link        dataUrl: &apos;&apos;, // 如果type是music或video，则要提供数据链接，默认为空        success: function() {            // 用户确认分享后执行的回调函数        },        cancel: function() {            // 用户取消分享后执行的回调函数        }         });        wx.onMenuShareTimeline({ //分享朋友圈        title: &apos;标题&apos;, // 分享标题        link: &apos;链接&apos;,        imgUrl: &apos;图片&apos;, // 分享图标        success: function() {            // 用户确认分享后执行的回调函数        },        cancel: function() {            // 用户取消分享后执行的回调函数        }    });}); wxx.error(function(res){//通过error接口处理失败验证    // config信息验证失败会执行error函数});</code></pre></li></ol><p>上面的流程多看几遍，对整个流程有个概念，其中最重要的一步就是下面这个借口注入权限。</p><h3 id="config接口注入权限"><a href="#config接口注入权限" class="headerlink" title="config接口注入权限"></a>config接口注入权限</h3><p>接入微信接口的最主要也是最重要一步步就是填写下面这些信息，填完这些信息之后，基本就好了。下面这些信息通常是通过后端接口来获取的。</p><pre><code>wx.config({    debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。    appId: &apos;&apos;, // 必填，公众号的唯一标识    timestamp: , // 必填，生成签名的时间戳    nonceStr: &apos;&apos;, // 必填，生成签名的随机串    signature: &apos;&apos;,// 必填，签名，见附录1    jsApiList: [] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2});</code></pre><h3 id="获取config配置信息："><a href="#获取config配置信息：" class="headerlink" title="获取config配置信息："></a>获取config配置信息：</h3><p>前端要获取上面那些信息，不用做太多东西，只要调后端接口就可以了。后端会把那些信息处理好，然后通过一个接口返给你这些参数。你要给后端传一个<strong>当前路由页面的完整url</strong>，后端就会返回上述的那些信息给你，后面就可以根据自己的需求调用相应的接口，自定义里面的东西。</p><h4 id="坑点：url"><a href="#坑点：url" class="headerlink" title="坑点：url"></a>坑点：url</h4><p>这里要注意的就是url的问题，如果url没有正确传递，后端也会返回信息，但是签名信息会是错误的。</p><p>上面提到的完整url指的是：’http(s)://‘部分，以及’？’后面的GET参数部分,但不包括’#’hash后面的部分。可以通过<code>location.href</code>来获取。</p><p><strong>注意</strong>： 如果你的vue项目，路由没有开启history 模式,也就是你的url上面包含“#”，这个时候要从后端正确获取签名，就需要<strong>去掉url上#后面的字符</strong>。（url去掉’#’hash部分，可用<code>location.href.split(&#39;#&#39;)[0]</code>）</p><h3 id="封装调用sdk注入："><a href="#封装调用sdk注入：" class="headerlink" title="封装调用sdk注入："></a>封装调用sdk注入：</h3><p>因为要在每个路由页面都注入sdk，这个肯定要复用的，不然那么多代码，看着就头大。</p><h4 id="我是这么做的："><a href="#我是这么做的：" class="headerlink" title="我是这么做的："></a>我是这么做的：</h4><ol><li>因为我把axios<a href="https://juejin.im/post/59fd982c6fb9a045170490df" target="_blank" rel="external">包了一层</a>，然后把axios接口，在main.js里面挂载到Vue实例。<br><img src="https://user-gold-cdn.xitu.io/2017/12/16/1605f3933091e9d2?w=535&amp;h=98&amp;f=png&amp;s=18864" alt=""></li><li>然后在<a href="https://juejin.im/post/59eddbfe6fb9a0450908abb4" target="_blank" rel="external">全局函数</a>里面调用这个接口，然后在每个路由页面的相应组件里面调用这个函数，把当前页面的url以及其他标题、图片什么的传进去。</li></ol><p>里面的具体步骤就不说了，最重要的是参考上面的那个流程，函数里面的东西也都是基于那个流程的。</p><h3 id="签名校验："><a href="#签名校验：" class="headerlink" title="签名校验："></a>签名校验：</h3><p>当你反复确认步骤都没有问题，微信sdk注入还是签名失败的时候，这个时候你就要考虑是不是后端那边的算法有问题，可以把后端返回的签名和微信提供的<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign" target="_blank" rel="external">JS 接口签名校验工具</a>生成的签名对比一下，或许是后端那边算法的问题也不一定。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>实不相瞒，当时我做的时候就是被url这个坑了，第一次做这个东西，没有经验，折腾了好久。引入sdk并不难，重要的是那个配置信息要填写正确，然后其他的就根据实际需求来做了。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><strong><a href="http://obkoro1.com/" target="_blank" rel="external">个人blog</a></strong> and <strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a></strong>  </p><p>以上2017.12.16</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h2&gt;&lt;p&gt;做微信的网页基本上都要接入微信的sdk，我在做的时候，也颇费了一番功夫，然后就想记录一下，供自己日后翻阅，以及让有需
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="微信" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>江湖再见</title>
    <link href="http://yoursite.com/2017/12/13/%E6%B1%9F%E6%B9%96%E5%86%8D%E8%A7%81/"/>
    <id>http://yoursite.com/2017/12/13/江湖再见/</id>
    <published>2017-12-13T10:10:47.000Z</published>
    <updated>2017-12-13T10:17:16.505Z</updated>
    
    <content type="html"><![CDATA[<p>事件：<a href="http://mp.weixin.qq.com/s/Lg2JgZuJ3JBFUnz-6NOHDQ" target="_blank" rel="external">http://mp.weixin.qq.com/s/Lg2JgZuJ3JBFUnz-6NOHDQ</a></p><h3 id="用脚投票"><a href="#用脚投票" class="headerlink" title="用脚投票"></a>用脚投票</h3><p>饱醉豚骂程序员，一竿子打翻一船的人，简叔还为之站队，深深感受到了简书的恶意。人微言轻决定用脚投票，删了所有文章，再也不来简书，可能程序员根本不是简书的用户群体吧，那么江湖再见。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/13/1604f5d85f5569a5?w=1310&amp;h=633&amp;f=png&amp;s=94258" alt="用脚投票"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;事件：&lt;a href=&quot;http://mp.weixin.qq.com/s/Lg2JgZuJ3JBFUnz-6NOHDQ&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://mp.weixin.qq.com/s/Lg2JgZuJ3JBFUnz-6N
      
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>手摸手教你在vue-cli里面使用vuex，以及vuex简介</title>
    <link href="http://yoursite.com/2017/12/09/%E6%89%8B%E6%91%B8%E6%89%8B%E6%95%99%E4%BD%A0%E5%9C%A8vue-cli%E9%87%8C%E9%9D%A2%E4%BD%BF%E7%94%A8vuex%EF%BC%8C%E4%BB%A5%E5%8F%8Avuex%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2017/12/09/手摸手教你在vue-cli里面使用vuex，以及vuex简介/</id>
    <published>2017-12-09T11:15:18.000Z</published>
    <updated>2017-12-09T11:18:01.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>这篇文章是在vue-cli里面使用vuex的一个极简demo，附带一些vuex的简单介绍。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。</p><blockquote><p>本文首发于我的个人blog：<a href="http://obkoro1.com/" target="_blank" rel="external">obkoro1.com</a></p></blockquote><h2 id="引入步骤"><a href="#引入步骤" class="headerlink" title="引入步骤"></a>引入步骤</h2><p>我创建了一个新的vue-cli里面什么东西都没有，只引用了vuex，这里是<a href="https://gitee.com/OBKoro1/blog_vuex" target="_blank" rel="external">码云地址</a>,可以下载下来，然后<code>npm install</code>、<code>npm run dev</code>试试看，里面vuex的使用地方也全都注释了一遍。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code>npm install vuex --save</code></pre><h3 id="在src目录下创建文件夹vuex"><a href="#在src目录下创建文件夹vuex" class="headerlink" title="在src目录下创建文件夹vuex"></a>在src目录下创建文件夹vuex</h3><p><img src="https://user-gold-cdn.xitu.io/2017/12/9/1603a90a59fc5676?w=363&amp;h=335&amp;f=png&amp;s=16366" alt="文件夹包含文件"></p><p>该文件夹包含以上文件，创建好了之后，我们一个一个文件来说里面都有什么东西。</p><h4 id="vuex-index-js"><a href="#vuex-index-js" class="headerlink" title="vuex/index.js"></a>vuex/index.js</h4><pre><code>import Vue from &apos;vue&apos;;import Vuex from &apos;vuex&apos;;import status from &apos;./modules/status/index&apos;;//引进模块Vue.use(Vuex);export default new Vuex.Store({  modules: {      //Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action    dataStatus:status,//访问这里面数据的时候要使用&apos;dataStatus&apos;  },});</code></pre><p>这是vuex的主文件store，这个例子是把state、mutation、action分割成模块，然后再将每个模块引用进这个index.js文件里面，等我们整个文件夹的文件都搭好之后，还要把文件引入到main.js里面、</p><h3 id="vuex-modules-status-index-js"><a href="#vuex-modules-status-index-js" class="headerlink" title="vuex/modules/status/index.js"></a>vuex/modules/status/index.js</h3><pre><code>import actions from &apos;./actions&apos;;import mutations from &apos;./mutations&apos;;//引入action和mutations export default {    state:{ //这里面是要读取或者写入数据的地方      msg:&apos;默认状态&apos;,  },  //state actions mutations顺序不能乱  actions: actions,  mutations: mutations,}</code></pre><p>这是一个模块里面的主文件，模块内部拥有自己的state、actions、mutions，是从上到下进行分割的。</p><h3 id="vuex-modules-status-mutation-type-js"><a href="#vuex-modules-status-mutation-type-js" class="headerlink" title="vuex/modules/status/mutation_type.js"></a>vuex/modules/status/mutation_type.js</h3><pre><code>//这个js文件里面只是一些变量，把action和mutation文件里面相同变量名的链接起来export const VUEX_TEST = &apos;VUEX_TEST&apos;;// 一般使用的是大写来命名变量，因为尤大也是这么做 2333</code></pre><h3 id="vuex-modules-status-actions-js"><a href="#vuex-modules-status-actions-js" class="headerlink" title="vuex/modules/status/actions.js"></a>vuex/modules/status/actions.js</h3><pre><code>import * as types from &apos;./mutation_type&apos;; //引入变量export default {  actionFn({commit},data){ //actionFn是在组件通过dispatch触发的函数名 可以理解成组件和actions的连接    commit(types.VUEX_TEST,data);    //types.VUEX_TEST 是要commit到mutation的哪个位置 变量的作用    //data 是传过来的参数  }};</code></pre><h3 id="vuex-modules-status-mutations-js"><a href="#vuex-modules-status-mutations-js" class="headerlink" title="vuex/modules/status/mutations.js"></a>vuex/modules/status/mutations.js</h3><pre><code>import * as types from &apos;./mutation_type&apos;;//引入变量export default {  //types.VUEX_TEST 代表接受哪个actions的commit 也就是上面引入变量的作用  [types.VUEX_TEST](state,data){     //第一个参数state是这个模块的state 第二个参数是传进来的数据     if(data.status==1){ //根据传进来的参数做各种操作      //这里就是操作state了，赋值之后，各个组件上面引用该数据的地方会自动更新            state.msg=data.text;    }else if(data.status==2){        state.msg=&apos;奕迅&apos;;    }    //这里是随便写的一个栗子    console.log(state.mg,data,&apos;mutation&apos;);   }};</code></pre><p>这两个文件里面有注释，解释的蛮清楚的。当把所有文件创建好了之后，再回过头来看看每个文件之间都有联系,多想想或许就懂点什么东西了 emmm</p><h4 id="vuex文件夹，文件目录以及下载"><a href="#vuex文件夹，文件目录以及下载" class="headerlink" title="vuex文件夹，文件目录以及下载"></a><a href="https://gitee.com/OBKoro1/blog_vuex/tree/master/src/vuex" target="_blank" rel="external">vuex文件夹</a>，文件目录以及下载</h4><h3 id="引入main-js"><a href="#引入main-js" class="headerlink" title="引入main.js"></a>引入main.js</h3><p><img src="https://user-gold-cdn.xitu.io/2017/12/9/1603ac7ca073cb0e?w=765&amp;h=427&amp;f=png&amp;s=49028" alt=""></p><p>上面的vuex文件夹只是搭建一个store，但是这样还不够，我们还要在项目里面使用这个。引用到main.js，如图所示。</p><h3 id="组件中如何使用。"><a href="#组件中如何使用。" class="headerlink" title="组件中如何使用。"></a>组件中如何使用。</h3><p><img src="https://user-gold-cdn.xitu.io/2017/12/9/1603acd24b3c1906?w=773&amp;h=875&amp;f=png&amp;s=97062" alt=""></p><p>使用的话就是像上面那么使用，本文只是一个简单的示例，还有更多骚操作，等大家上手之后再慢慢摸索咯。</p><h2 id="git地址"><a href="#git地址" class="headerlink" title="git地址"></a>git地址</h2><p>感觉写的蛮乱的，大家如果看不太懂的话，可以到<a href="https://gitee.com/OBKoro1/blog_vuex" target="_blank" rel="external">码云</a>去下载文件，然后自己跑一跑，多看看，试一试就应该没问题了。</p><h2 id="vuex简介"><a href="#vuex简介" class="headerlink" title="vuex简介"></a>vuex简介</h2><p>通常我是希望大家先学会用，然后再了解后面的机制，每次我看博文的时候，一大段原理贴上来，都给我弄懵逼了。。</p><p>vuex主要是用来<strong>复杂项目之间的组件通信功能</strong>，简单的项目不要用这套复杂的事件以及状态管理机制。项目如果不够复杂的话推荐我之前写的：<a href="https://juejin.im/post/59eddbfe6fb9a0450908abb4" target="_blank" rel="external">在vue项目中 如何定义全局变量 全局函数</a>，使用全局变量的形式的也可以实现需求。</p><h3 id="vuex实现的作用：数据共享机制"><a href="#vuex实现的作用：数据共享机制" class="headerlink" title="vuex实现的作用：数据共享机制"></a>vuex实现的作用：数据共享机制</h3><p>通过统一的数据中心store维护状态数据，每个组件进行更新的时候，通知数据中心store。再由stroe将共享的状态，触发每一个调用它的组件的更新。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/9/1603ae6d33eae6db?w=554&amp;h=570&amp;f=png&amp;s=153482" alt="store触发组件更新"></p><h3 id="vuex的工作流程"><a href="#vuex的工作流程" class="headerlink" title="vuex的工作流程"></a>vuex的工作流程</h3><p>大家先仔细看看下面这张图，理解他的工作机制。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/9/1603ae858f7da6cd?w=789&amp;h=530&amp;f=png&amp;s=148466" alt=""></p><ol><li>在vue组件里面，通过dispatch来触发actions提交修改数据的操作。</li><li>然后再通过actions的commit来触发mutations来修改数据。</li><li>mutations接收到commit的请求，就会自动通过Mutate来修改state（数据中心里面的数据状态）里面的数据。</li><li>最后由store触发每一个调用它的组件的更新</li></ol><h3 id="注意：这套模型是单向流动的"><a href="#注意：这套模型是单向流动的" class="headerlink" title="注意：这套模型是单向流动的"></a>注意：这套模型是单向流动的</h3><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>以上就是本文的所有内容了，希望可以帮到大家。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><strong><a href="http://obkoro1.com/" target="_blank" rel="external">个人blog</a></strong> and <strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a></strong>  </p><p>以上2017.12.9</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h2&gt;&lt;p&gt;这篇文章是在vue-cli里面使用vuex的一个极简demo，附带一些vuex的简单介绍。有需要的朋友可以做一下参考
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="Vue-cli" scheme="http://yoursite.com/tags/Vue-cli/"/>
    
      <category term="Vuex" scheme="http://yoursite.com/tags/Vuex/"/>
    
  </entry>
  
  <entry>
    <title>cookie、localStorage和sessionStorage 三者之间的区别以及存储、获取、删除等使用方式</title>
    <link href="http://yoursite.com/2017/11/25/cookie%E3%80%81localStorage%E5%92%8CsessionStorage%20%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%AD%98%E5%82%A8%E3%80%81%E8%8E%B7%E5%8F%96%E3%80%81%E5%88%A0%E9%99%A4%E7%AD%89%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/11/25/cookie、localStorage和sessionStorage 三者之间的区别以及存储、获取、删除等使用方式/</id>
    <published>2017-11-25T12:51:07.000Z</published>
    <updated>2017-11-28T02:24:28.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>前端开发的时候，在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是cookie，localstorage和sessionStorage ，这是大家都知道的。本文的主要内容就是针对这三者的存放、获取，区别、应用场景。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。</p><blockquote><p>本文首发于我的个人blog：<a href="http://obkoro1.com/" target="_blank" rel="external">obkoro1.com</a></p></blockquote><h2 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h2><p>很多文档都是说了一大堆，后面用法都没有说，先要学会怎么用，不然后面的都是扯淡，所以这里我先把使用方式弄出来。</p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie:"></a>cookie:</h3><p><strong>保存cookie值：</strong></p><pre><code>var dataCookie=&apos;110&apos;;document.cookie = &apos;token&apos; + &quot;=&quot; +dataCookie; </code></pre><p><strong>获取指定名称的cookie值</strong></p><pre><code> function getCookie(name) { //获取指定名称的cookie值// (^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组；var arr = document.cookie.match(new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;));if(arr != null) {  console.log(arr);  return unescape(arr[2]);}return null;} var cookieData=getCookie(&apos;token&apos;); //cookie赋值给变量。</code></pre><p>先贴这两个最基础的方法，文末有个<a href="http://obkoro1.com/article-demo/2017/cookieStorage/index.html" target="_blank" rel="external">demo</a>里面还有如何设置cookie过期时间，以及删除cookie的、</p><h3 id="localStorage和sessionStorage"><a href="#localStorage和sessionStorage" class="headerlink" title="localStorage和sessionStorage:"></a>localStorage和sessionStorage:</h3><p><strong>localStorage和sessionStorage所使用的方法是一样的</strong>，下面以sessionStorage为栗子：</p><pre><code>var name=&apos;sessionData&apos;;var num=120;sessionStorage.setItem(name,num);//存储数据sessionStorage.setItem(&apos;value2&apos;,119);let dataAll=sessionStorage.valueOf();//获取全部数据console.log(dataAll,&apos;获取全部数据&apos;);var dataSession=sessionStorage.getItem(name);//获取指定键名数据var dataSession2=sessionStorage.sessionData;//sessionStorage是js对象，也可以使用key的方式来获取值 console.log(dataSession,dataSession2,&apos;获取指定键名数据&apos;);sessionStorage.removeItem(name); //删除指定键名数据  console.log(dataAll,&apos;获取全部数据1&apos;); sessionStorage.clear();//清空缓存数据：localStorage.clear();  console.log(dataAll,&apos;获取全部数据2&apos;);  </code></pre><p>使用方式，基本上就上面这些，其实也是比较简单的。大家可以把这个copy到自己的编译器里面，或者文末有个<a href="http://obkoro1.com/article-demo/2017/cookieStorage/index.html" target="_blank" rel="external">demo</a>，可以点开看看。</p><h2 id="三者的异同："><a href="#三者的异同：" class="headerlink" title="三者的异同："></a>三者的异同：</h2><p>上面的使用方式说好了，下面就唠唠三者之间的区别，这个问题其实很多大厂面试的时候也都会问到，所以可以注意一下这几个之间的区别。</p><h3 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a>生命周期：</h3><p>cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效</p><p>localStorage：除非被手动清除，否则将会永久保存。</p><p>sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。</p><h3 id="存放数据大小："><a href="#存放数据大小：" class="headerlink" title="存放数据大小："></a>存放数据大小：</h3><p>cookie：4KB左右</p><p>localStorage和sessionStorage：可以保存5MB的信息。</p><h3 id="http请求："><a href="#http请求：" class="headerlink" title="http请求："></a>http请求：</h3><p>cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</p><p>localStorage和sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信</p><h3 id="易用性："><a href="#易用性：" class="headerlink" title="易用性："></a>易用性：</h3><p>cookie：需要程序员自己封装，源生的Cookie接口不友好</p><p>localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</p><h2 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h2><p>从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。</p><p>storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的，哈哈哈你们懂得。</p><p>localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。</p><h2 id="浏览器支持情况："><a href="#浏览器支持情况：" class="headerlink" title="浏览器支持情况："></a>浏览器支持情况：</h2><p>localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/25/15ff2d54764e53af?w=861&amp;h=113&amp;f=png&amp;s=9592" alt=""></p><p>cookie的浏览器支持没有找到，可以通过下面这段代码来判断所使用的浏览器是否支持cookie：</p><pre><code>if(navigator.cookieEnabled) {  alert(&quot;你的浏览器支持cookie功能&quot;);//提示浏览器支持cookie  } else {  alert(&quot;你的浏览器不支持cookie&quot;);//提示浏览器不支持cookie   }</code></pre><h3 id="数据存放处："><a href="#数据存放处：" class="headerlink" title="数据存放处："></a>数据存放处：</h3><p><img src="https://user-gold-cdn.xitu.io/2017/11/25/15ff2f727028f37b?w=1028&amp;h=378&amp;f=png&amp;s=28065" alt="Cookie、localStorage、sessionStorage数据存放处"></p><h3 id="番外：各浏览器Cookie大小、个数限制。"><a href="#番外：各浏览器Cookie大小、个数限制。" class="headerlink" title="番外：各浏览器Cookie大小、个数限制。"></a>番外：各浏览器Cookie大小、个数限制。</h3><p>cookie 使用起来还是需要小心一点，有兴趣的可以看一下这个<a href="https://www.cnblogs.com/henryhappier/archive/2011/03/03/1969564.html" target="_blank" rel="external">链接</a>。</p><h3 id="demo链接"><a href="#demo链接" class="headerlink" title="demo链接"></a>demo链接</h3><p>把上面的demo代码，上传到github上面了，有需要的小伙伴们，可以看一下。<a href="http://obkoro1.com/article-demo/2017/cookieStorage/index.html" target="_blank" rel="external">传送门</a></p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>最后要说的是：不要把什么数据都放在 Cookie、localStorage 和 sessionStorage中，毕竟前端的安全性这么低。只要打开控制台就可以任意的修改 Cookie、localStorage 和 sessionStorage的数据了。涉及到金钱或者其他比较重要的信息，还是要存在后台比较好。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><a href="http://obkoro1.com/" target="_blank" rel="external">blog网站</a>  and <strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a> </strong>  </p><p>以上2017.11.25</p><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="http://www.w3school.com.cn/html5/html_5_webstorage.asp" target="_blank" rel="external">HTML 5 Web 存储</a><br><a href="http://blog.csdn.net/mafan121/article/details/60133107" target="_blank" rel="external">localStorage和sessionStorage详解</a><br><a href="https://segmentfault.com/a/1190000002723469" target="_blank" rel="external">详说 Cookie, LocalStorage 与 SessionStorage</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h2&gt;&lt;p&gt;前端开发的时候，在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="-js - html5" scheme="http://yoursite.com/tags/js-html5/"/>
    
  </entry>
  
  <entry>
    <title>vue router 使用params query传参，以及有什么区别</title>
    <link href="http://yoursite.com/2017/11/12/vue-router-%E4%BD%BF%E7%94%A8params-query%E4%BC%A0%E5%8F%82%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2017/11/12/vue-router-使用params-query传参，以及有什么区别/</id>
    <published>2017-11-12T10:11:52.000Z</published>
    <updated>2017-11-12T10:13:04.521Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>传参是前端经常需要用的一个操作，很多场景都会需要用到上个页面的参数，本文将会详细介绍vue router 是如何进行传参的，以及一些小细节问题。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。</p><blockquote><p>本文首发于我的个人blog：<a href="http://obkoro1.com/" target="_blank" rel="external">obkoro1.com</a></p></blockquote><h2 id="Vue-router如何传参"><a href="#Vue-router如何传参" class="headerlink" title="Vue router如何传参"></a>Vue router如何传参</h2><h3 id="params、query是什么？"><a href="#params、query是什么？" class="headerlink" title="params、query是什么？"></a>params、query是什么？</h3><p> params：/router1/:id ，/router1/123，/router1/789 ,<strong>这里的id叫做params</strong></p><p> query：/router1?id=123 ,/router1?id=456 ,这里的id叫做query。</p><h3 id="路由界面："><a href="#路由界面：" class="headerlink" title="路由界面："></a>路由界面：</h3><p>router.js:</p><p>路由设置这里，<strong>当你使用params方法传参的时候，要在路由后面加参数名，</strong>并且传参的时候，参数名要跟路由后面设置的参数名对应。使用query方法，就没有这种限制，直接在跳转里面用就可以。</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/12/5a6149e063affb11b03b105c0b20a76c" alt=""></p><p><strong>注意：</strong>如果路由上面不写参数，也是可以传过去的，但不会在url上面显示出你的参数，并且当你跳到别的页面或者刷新页面的时候<strong>参数会丢失</strong>（如下图所示），那依赖这个参数的http请求或者其他操作就会失败。</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/12/b26ef6ec935a56ee5ab1fe354b888178" alt=""></p><p>注意看上面的路由参数，id这个参数是我们有设置在路由上面的，id2我没有设置在路由里面，所以刷新之后id2就不见了，在项目中，我们总不可能要求用户不能刷新吧。</p><h3 id="组件1："><a href="#组件1：" class="headerlink" title="组件1："></a>组件1：</h3><pre><code>&lt;template&gt;  &lt;div class=&quot;app_page&quot;&gt;    &lt;h1&gt;从这个路由传参到别的路由&lt;/h1&gt;    &lt;router-link :to=&quot;{ name:&apos;router1&apos;,params: { id: status ,id2: status3},query: { queryId:  status2 }}&quot; &gt;      router-link跳转router1    &lt;/router-link&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  name: &apos;app_page&apos;,  data () {    return {      status:110,      status2:120,      status3:119    }  },}&lt;/script&gt;</code></pre><h3 id="编程式导航跳转："><a href="#编程式导航跳转：" class="headerlink" title="编程式导航跳转："></a>编程式导航跳转：</h3><p>上面的router-link传参，也可以使用<a href="https://router.vuejs.org/zh-cn/essentials/navigation.html" target="_blank" rel="external">router文档</a>里面的编程式导航来跳转传参。</p><pre><code>this.$router.push({  name:&apos;router1&apos;,params: { id: status ,id2: status3},query: { queryId:  status2 }});//编程跳转写在一个函数里面，通过click等方法来触发</code></pre><p><strong>这两种传参效果是一模一样的，编程式导航，可以用来做判断跳转，比如是否授权，是否登录，等等状态</strong>，对此不太了解的小伙伴们，可以跳过这个编程式导航，以后再来看。</p><h3 id="组件2："><a href="#组件2：" class="headerlink" title="组件2："></a>组件2：</h3><pre><code>&lt;template&gt;  &lt;div class=&quot;router1&quot;&gt;    &lt;h1&gt;接收参数的路由&lt;/h1&gt;    &lt;h1&gt; params.id：{{ $route.params }}&lt;/h1&gt;    &lt;h1&gt;query.status:{{ $route.query.queryId }}&lt;/h1&gt;    &lt;keep-alive&gt;      &lt;router-view&gt;&lt;/router-view&gt;    &lt;/keep-alive&gt;  &lt;/div&gt;&lt;/template&gt;</code></pre><p>传参还是比较简单的，按着上面组件的使用方法就可以成功传过去了。</p><p><strong>提示：</strong>获取路由上面的参数，用的是$route，后面没有r。</p><h3 id="params传参和query传参有什么区别："><a href="#params传参和query传参有什么区别：" class="headerlink" title="params传参和query传参有什么区别："></a>params传参和query传参有什么区别：</h3><p><img src="https://user-gold-cdn.xitu.io/2017/11/12/5327acc0b3dcc403b4316ce00c808221" alt=""></p><p>1、params是路由的一部分,必须要有。query是拼接在url后面的参数，没有也没关系。</p><p><strong>params一旦设置在路由，params就是路由的一部分</strong>，如果这个路由有params传参，但是在跳转的时候没有传这个参数，会导致跳转失败或者页面会没有内容。</p><p>比如：跳转/router1/:id</p><pre><code>&lt;router-link :to=&quot;{ name:&apos;router1&apos;,params: { id: status}}&quot; &gt;正确&lt;/router-link&gt;&lt;router-link :to=&quot;{ name:&apos;router1&apos;,params: { id2: status}}&quot;&gt;错误&lt;/router-link&gt;</code></pre><p>2、params、query不设置也可以传参，params不设置的时候，刷新页面或者返回参数会丢失，这一点的在上面说过了</p><h2 id="后话："><a href="#后话：" class="headerlink" title="后话："></a>后话：</h2><p>本文到这里就结束了，写的不好的地方，请各位大佬们见谅。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><a href="http://obkoro1.com/" target="_blank" rel="external">blog网站</a>  and <strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a> </strong></p><p>以上2017.11.12</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h2&gt;&lt;p&gt;传参是前端经常需要用的一个操作，很多场景都会需要用到上个页面的参数，本文将会详细介绍vue router 是如何进行
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
      <category term="传参" scheme="http://yoursite.com/tags/%E4%BC%A0%E5%8F%82/"/>
    
  </entry>
  
  <entry>
    <title>在Vue-cli里基于axios封装复用请求</title>
    <link href="http://yoursite.com/2017/11/05/%E5%9C%A8Vue-cli%E9%87%8C%E5%9F%BA%E4%BA%8Eaxios%E5%B0%81%E8%A3%85%E5%A4%8D%E7%94%A8%E8%AF%B7%E6%B1%82/"/>
    <id>http://yoursite.com/2017/11/05/在Vue-cli里基于axios封装复用请求/</id>
    <published>2017-11-05T07:54:18.000Z</published>
    <updated>2017-11-05T07:56:27.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>自从Vue2.0推荐大家使用 axios 开始，axios 被越来越多的人所了解。使用axios发起一个请求对大家来说是比较简单的事情，但是axios没有进行封装复用，项目越来越大，引起的代码冗余。就会非常麻烦的一件事。所以本文会详细的跟大家介绍，如何封装请求，并且在项目组件中复用请求。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。</p><blockquote><p>本文首发于我的个人blog：<a href="http://obkoro1.com/" target="_blank" rel="external">obkoro1.com</a></p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>只用安装一个axios就可以了。</p><pre><code>npm install axios --save</code></pre><h3 id="接口代理设置"><a href="#接口代理设置" class="headerlink" title="接口代理设置"></a>接口代理设置</h3><p>为了请求可以正常发送，我们一般要进行一个接口代理的配置，这样可以避免请求跨域，项目打包之后，后端一般也要搭建一个nginx之类的东西进行转发请求，不然请求会因为跨域问题失败的。</p><pre><code>//文件位置：config/index.jsproxyTable: {  &apos;/api&apos;: {    target: &apos;http://47.95.xxx.246:8080&apos;,  // 通过本地服务器将你的请求转发到这个地址    changeOrigin: true,  // 设置这个参数可以避免跨域    pathRewrite: {      &apos;/api&apos;: &apos;/&apos;    }  },},</code></pre><p><img src="https://user-gold-cdn.xitu.io/2017/10/31/3af73c621b7523aa0f3a2fd95d1bd38c" alt=""></p><p>设置好了之后，当你在项目中要调用<code>http://47.95.xxx.246:8080</code>这个服务器里面的接口，可以直接用<code>/api</code>代替服务器地址。</p><h2 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h2><h3 id="main-js入口文件中："><a href="#main-js入口文件中：" class="headerlink" title="main.js入口文件中："></a>main.js入口文件中：</h3><pre><code>import axios from &apos;axios&apos;;//引入文件Vue.prototype.$http = axios;//将axios挂载到Vue实例中的$ajax上面,在项目中的任何位置通过this.$http使用</code></pre><h3 id="没有封装发起请求："><a href="#没有封装发起请求：" class="headerlink" title="没有封装发起请求："></a>没有封装发起请求：</h3><pre><code>//没有封装的时候，在组件中发起请求的方式：   this.$ajax({       url:&apos;/api/articles&apos;,//api 代理到json文件地址，后面的后缀是文件中的对象或者是数组       method:&apos;get&apos;,//请求方式       //这里可以添加axios文档中的各种配置     }).then(function (res) {       console.log(res,&apos;成功&apos;);     }).catch(function (err) {       console.log(err,&apos;错误&apos;);     })//还可以像下面这么简写  this.$ajax.get(&apos;api/publishContent&apos;).then((res) =&gt; {   console.log(res,&apos;请求成功&apos;)  },(err)=&gt;{    console.log(err,&apos;请求失败&apos;);  });</code></pre><h2 id="封装请求"><a href="#封装请求" class="headerlink" title="封装请求"></a>封装请求</h2><p>封装的时候，我通常喜欢把请求抽象成三个文件，文件位置放在src中，只要你能引用到，就没问题，如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/4/0eaae692ac8801448a0a7300206d6144" alt=""></p><p>创建三个.js文件，里面我都很认真的注释了，我就直接贴图片了，在文末我把这三个文件的地址发出来，需要的小伙伴自取。</p><p>fetch.js：</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/5/3cd9e9f1ebe11929f940d567870b4ec9" alt=""></p><p>url.js:</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/5/f70bfc90db9cb1c40725e179efbd4ab5" alt=""></p><p>api.js</p><p><img src="https://user-gold-cdn.xitu.io/2017/11/5/250690aa2ca666b6ef48f69483731ae0" alt=""></p><h3 id="在组件里面如何使用接口："><a href="#在组件里面如何使用接口：" class="headerlink" title="在组件里面如何使用接口："></a>在组件里面如何使用接口：</h3><p><img src="https://user-gold-cdn.xitu.io/2017/11/5/2ba68f2fad37c0285aeb0ba9e6e86a1e" alt=""></p><h3 id="封装axios文件地址在这里：传送门"><a href="#封装axios文件地址在这里：传送门" class="headerlink" title="封装axios文件地址在这里：传送门"></a>封装axios文件地址在这里：<a href="https://github.com/OBKoro1/article-demo/tree/master/2017/axios" target="_blank" rel="external">传送门</a></h3><p>代码注释什么的，已经蛮多了，跟着文章一步一步走，实现封装axios请求，没毛病的。本文并没有把很多功能都完整的列出来，主要是追求一个上手，剩下的东西，各位小伙伴们可以自行研究。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><a href="http://obkoro1.com/" target="_blank" rel="external">blog网站</a>  and <strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a> </strong></p><p>以上2017.11.5</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h2&gt;&lt;p&gt;自从Vue2.0推荐大家使用 axios 开始，axios 被越来越多的人所了解。使用axios发起一个请求对大家来
      
    
    </summary>
    
      <category term="vue-cli" scheme="http://yoursite.com/categories/vue-cli/"/>
    
    
      <category term="axios" scheme="http://yoursite.com/tags/axios/"/>
    
      <category term="axios封装" scheme="http://yoursite.com/tags/axios%E5%B0%81%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Vue-cli 使用json server在本地模拟请求数据</title>
    <link href="http://yoursite.com/2017/11/01/Vue-cli-%E4%BD%BF%E7%94%A8json-server%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%A8%A1%E6%8B%9F%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2017/11/01/Vue-cli-使用json-server在本地模拟请求数据/</id>
    <published>2017-11-01T05:55:01.000Z</published>
    <updated>2017-11-05T07:55:33.538Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>开发的时候，前后端不论是否分离，接口多半是滞后于页面开发的。所以建立一个REST风格的API接口，给前端页面提供虚拟的数据，是非常有必要的。json server 作为模拟工具，因为设置简单，容易上手。本文是做一个简单的上手介绍，有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。</p><blockquote><p>本文首发于我的个人blog：<a href="http://obkoro1.com/" target="_blank" rel="external">obkoro1.com</a></p></blockquote><h3 id="json-server-工具"><a href="#json-server-工具" class="headerlink" title="json server 工具:"></a>json server 工具:</h3><p>在后台还没给接口之前，使用JSON-Server搭建一台JSON服务器，将接口要返回的数据放在json文件里面。然后请求这些数据，这样我们可以先做一些东西，等后台接口好了之后直接替换就可以了，不必一直傻傻的等后端的接口。</p><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><pre><code>npm install json-server --save //json servernpm install axios --save //使用axios发送请求</code></pre><h4 id="json文件："><a href="#json文件：" class="headerlink" title="json文件："></a>json文件：</h4><p>创建一个json文件，起名叫db.json，文件放置在跟index.html平级的目录中，也可以放置在static文件夹中，db.json文件里面的内容，是一个对象。</p><h3 id="设置："><a href="#设置：" class="headerlink" title="设置："></a>设置：</h3><p>位置： build/dev-server.js</p><pre><code>//json-server 假数据var jsonServer = require(&apos;json-server&apos;) //引入文件var apiServer = jsonServer.create(); //创建服务器var apiRouter = jsonServer.router(&apos;db.json&apos;) //引入json 文件 ，这里的地址就是你json文件的地址var middlewares = jsonServer.defaults(); //返回JSON服务器使用的中间件。apiServer.use(middlewares)apiServer.use(&apos;/json&apos;,apiRouter)apiServer.listen( port + 1,function(){ //json服务器端口:比如你使用8080,这里的json服务器就是8081端口  console.log(&apos;JSON Server is running&apos;)  //json server成功运行会在git bash里面打印出&apos;JSON Server is running&apos;})</code></pre><p>如图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2017/10/31/1cd6d748943c968c65eb135b322c6f0b" alt=""></p><h3 id="请求接口代理："><a href="#请求接口代理：" class="headerlink" title="请求接口代理："></a>请求接口代理：</h3><pre><code>proxyTable: {  &apos;/api&apos;: {    target: &apos;http://localhost:8081/&apos;,  // 通过本地服务器将你的请求转发到这个地址    changeOrigin: true,  // 设置这个参数可以避免跨域    pathRewrite: {      &apos;/api&apos;: &apos;/&apos;    }  },},</code></pre><p>如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2017/10/31/3af73c621b7523aa0f3a2fd95d1bd38c" alt=""></p><h3 id="npm-run-dev启动项目可以访问到你的json文件："><a href="#npm-run-dev启动项目可以访问到你的json文件：" class="headerlink" title="npm run dev启动项目可以访问到你的json文件："></a>npm run dev启动项目可以访问到你的json文件：</h3><p>现在服务器已经成功启动，在地址栏输入 localhost:8081，就可以看到的json文件，加上相应后缀即可访问文件里面的数据。下面几张图片出自：<a href="http://blog.csdn.net/biubiubiuzzz/article/details/78066621" target="_blank" rel="external">biubiubiuzzz</a></p><p>jsonserver服务器：</p><p><img src="https://user-gold-cdn.xitu.io/2017/10/31/50baa471e48b88d8dc595e0dc8cd60b7" alt="jsonserver服务器"></p><p>json数据：<br><img src="https://user-gold-cdn.xitu.io/2017/10/31/cd31ad94fb979187133c4d1c8f5d9572" alt="json数据"></p><h2 id="axios请求json数据："><a href="#axios请求json数据：" class="headerlink" title="axios请求json数据："></a>axios请求json数据：</h2><p>光看到这些数据可不行，我们还需要发起请求，请求到这些数据，然后执行各种各样的骚操作。</p><h3 id="main-js文件中："><a href="#main-js文件中：" class="headerlink" title="main.js文件中："></a>main.js文件中：</h3><pre><code>import axios from &apos;axios&apos;;//引入文件Vue.prototype.$ajax = axios;//将axios挂载到Vue实例中的$ajax上面,在项目中的任何位置通过this.$ajax使用</code></pre><p>在组件中的使用方式，比如：</p><pre><code>   this.$ajax({       url:&apos;/api/articles&apos;,//api 代理到json文件地址，后面的后缀是文件中的对象或者是数组       method:&apos;get&apos;,//请求方式       //这里可以添加axios文档中的各种配置     }).then(function (res) {       console.log(res,&apos;成功&apos;);     }).catch(function (err) {       console.log(err,&apos;错误&apos;);     })//还可以像下面这么简写  this.$ajax.get(&apos;api/publishContent&apos;).then((res) =&gt; {   console.log(res,&apos;请求成功&apos;)  },(err)=&gt;{    console.log(err,&apos;请求失败&apos;);  });</code></pre><h3 id="JSON-Server只接受GET请求，GitHub上提到："><a href="#JSON-Server只接受GET请求，GitHub上提到：" class="headerlink" title="JSON-Server只接受GET请求，GitHub上提到："></a>JSON-Server只接受GET请求，GitHub上提到：</h3><p>If you make POST, PUT, PATCH or DELETE requests, changes will be automatically and safely saved to db.json using lowdb.</p><p>lowdb介绍： <a href="http://www.jianshu.com/p/11d04a4c22af" target="_blank" rel="external">http://www.jianshu.com/p/11d04a4c22af</a></p><h3 id="文档："><a href="#文档：" class="headerlink" title="文档："></a>文档：</h3><p>附上<a href="https://github.com/typicode/json-server" target="_blank" rel="external">json server</a>的github，和<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="external">axios</a>的中文文档，大家可以进去研究一下。</p><p>json server设置和使用起来还是蛮方便的，大家感兴趣的话，可以跟着文章设置一波。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><a href="http://obkoro1.com/" target="_blank" rel="external">blog网站</a>  and <strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a> </strong></p><p>以上2017.11.1</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><p><a href="http://blog.csdn.net/u012911742/article/details/73162761" target="_blank" rel="external">JSON-Server使用</a><br><a href="http://blog.csdn.net/biubiubiuzzz/article/details/78066621" target="_blank" rel="external"> vue-cli下配置json-server</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h2&gt;&lt;p&gt;开发的时候，前后端不论是否分离，接口多半是滞后于页面开发的。所以建立一个REST风格的API接口，给前端页面提供虚拟
      
    
    </summary>
    
      <category term="工具类" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="vue-cli配置" scheme="http://yoursite.com/tags/vue-cli%E9%85%8D%E7%BD%AE/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="axios" scheme="http://yoursite.com/tags/axios/"/>
    
  </entry>
  
  <entry>
    <title>在vue项目中 如何定义全局变量 全局函数</title>
    <link href="http://yoursite.com/2017/10/23/%E5%9C%A8vue%E9%A1%B9%E7%9B%AE%E4%B8%AD-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F-%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/10/23/在vue项目中-如何定义全局变量-全局函数/</id>
    <published>2017-10-23T13:30:40.000Z</published>
    <updated>2017-10-23T13:34:19.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>如题，在项目中，经常有些函数和变量是需要复用，比如说网站服务器地址，从后台拿到的：用户的登录token,用户的地址信息等，这时候就需要设置一波全局变量和全局函数，这两个设置不太难，而且有一些共通之处，可能有一些朋友对此不太了解，所以随便写出来分享一波。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。</p><h2 id="定义全局变量"><a href="#定义全局变量" class="headerlink" title="定义全局变量"></a>定义全局变量</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>设置一个专用的的全局变量模块文件，模块里面定义一些变量初始状态，用export default 暴露出去，在main.js里面使用Vue.prototype挂载到vue实例上面或者在其它地方需要使用时，引入该模块便可。</p><h3 id="全局变量模块文件："><a href="#全局变量模块文件：" class="headerlink" title="全局变量模块文件："></a>全局变量模块文件：</h3><p> Global.vue文件：</p><pre><code>&lt;script&gt;const serverSrc=&apos;www.baidu.com&apos;;const token=&apos;12345678&apos;;const hasEnter=false;const userSite=&quot;中国钓鱼岛&quot;;  export default  {    userSite,//用户地址    token,//用户token身份    serverSrc,//服务器地址    hasEnter,//用户登录状态  }&lt;/script&gt;</code></pre><h3 id="使用方式1："><a href="#使用方式1：" class="headerlink" title="使用方式1："></a>使用方式1：</h3><p><strong>在需要的地方引用进全局变量模块文件</strong>，然后通过文件里面的变量名字获取全局变量参数值。</p><p><strong>在text1.vue组件中使用：</strong></p><pre><code>&lt;template&gt;    &lt;div&gt;{{ token }}&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import global_ from &apos;../../components/Global&apos;//引用模块进来export default { name: &apos;text&apos;,data () {    return {         token:global_.token,//将全局变量赋值到data里面，也可以直接使用global_.token        }    }}&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;</code></pre><h3 id="使用方式2："><a href="#使用方式2：" class="headerlink" title="使用方式2："></a>使用方式2：</h3><p>在程序入口的main.js文件里面，将上面那个Global.vue文件挂载到Vue.prototype。</p><pre><code>import global_ from &apos;./components/Global&apos;//引用文件Vue.prototype.GLOBAL = global_//挂载到Vue实例上面</code></pre><p>接着在整个项目中不需要再通过引用Global.vue模块文件，直接通过this就可以直接访问Global文件里面定义的全局变量。</p><p>text2.vue：</p><pre><code>&lt;template&gt;    &lt;div&gt;{{ token }}&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { name: &apos;text&apos;,data () {    return {         token:this.GLOBAL.token,//直接通过this访问全局变量。        }    }}&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;</code></pre><h3 id="Vuex也可以设置全局变量："><a href="#Vuex也可以设置全局变量：" class="headerlink" title="Vuex也可以设置全局变量："></a>Vuex也可以设置全局变量：</h3><p>通过vuex来存放全局变量，这里东西比较多，也相对复杂一些，有兴趣的小伙伴们，可自行查阅资料，折腾一波、</p><h2 id="定义全局函数"><a href="#定义全局函数" class="headerlink" title="定义全局函数"></a>定义全局函数</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>新建一个模块文件，然后在main.js里面通过Vue.prototype将函数挂载到Vue实例上面，通过this.函数名，来运行函数。</p><h3 id="1-在main-js里面直接写函数"><a href="#1-在main-js里面直接写函数" class="headerlink" title="1. 在main.js里面直接写函数"></a>1. 在main.js里面直接写函数</h3><p>简单的函数可以直接在main.js里面直接写</p><pre><code>Vue.prototype.changeData = function (){//changeData是函数名  alert(&apos;执行成功&apos;);}</code></pre><p>组件中调用：</p><pre><code>this.changeData();//直接通过this运行函数</code></pre><h3 id="2-写一个模块文件，挂载到main-js上面。"><a href="#2-写一个模块文件，挂载到main-js上面。" class="headerlink" title="2. 写一个模块文件，挂载到main.js上面。"></a>2. 写一个模块文件，挂载到main.js上面。</h3><p>base.js文件，文件位置可以放在跟main.js同一级，方便引用</p><pre><code>exports.install = function (Vue, options) {   Vue.prototype.text1 = function (){//全局函数1    alert(&apos;执行成功1&apos;);    };    Vue.prototype.text2 = function (){//全局函数2    alert(&apos;执行成功2&apos;);    };};</code></pre><p>main.js入口文件：</p><pre><code>import base from &apos;./base&apos;//引用Vue.use(base);//将全局函数当做插件来进行注册</code></pre><p>组件里面调用：</p><pre><code>this.text1();this.text2();</code></pre><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>上面就是如何定义全局变量 全局函数的内容了，这里的全局变量全局函数可以不局限于vue项目，vue-cli是用了webpack做模块化，其他模块化开发，定义全局变量、函数的套路基本上是差不多。上文只是对全局变量，全局函数的希望看完本文能给大家一点帮助。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><a href="http://obkoro1.com/" target="_blank" rel="external">blog网站</a>  and <strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a> </strong></p><p>以上2017.10.23</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><p><a href="http://www.jb51.net/article/115093.htm" target="_blank" rel="external">详解VUE 定义全局变量的几种实现方式</a><br><a href="http://www.jianshu.com/p/04dffe7a6b74" target="_blank" rel="external"> Vue中如何定义全局函数</a><br><a href="http://www.cnblogs.com/dupd/p/6716386.html" target="_blank" rel="external">Vue.use源码分析</a><br><a href="https://segmentfault.com/q/1010000006854993" target="_blank" rel="external">export default</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h2&gt;&lt;p&gt;如题，在项目中，经常有些函数和变量是需要复用，比如说网站服务器地址，从后台拿到的：用户的登录token,用户的地址信
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="vue-cli配置" scheme="http://yoursite.com/tags/vue-cli%E9%85%8D%E7%BD%AE/"/>
    
      <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>js 计算两个时间的时间差</title>
    <link href="http://yoursite.com/2017/10/15/js-%E8%AE%A1%E7%AE%97%E4%B8%A4%E4%B8%AA%E6%97%B6%E9%97%B4%E7%9A%84%E6%97%B6%E9%97%B4%E5%B7%AE/"/>
    <id>http://yoursite.com/2017/10/15/js-计算两个时间的时间差/</id>
    <published>2017-10-15T12:07:31.000Z</published>
    <updated>2017-10-16T03:39:43.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>如题，就像题目说的需要计算出时间差，虽然不太难，但这个需求经常会在项目中遇到的，我在这边做一下整理，希望能够尽量全的整理出来。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。</p><h2 id="计算时间差原理："><a href="#计算时间差原理：" class="headerlink" title="计算时间差原理："></a>计算时间差原理：</h2><h3 id="getTime-方法"><a href="#getTime-方法" class="headerlink" title="getTime()方法"></a>getTime()方法</h3><p>方法定义： getTime() 方法可返回距 1970 年 1 月 1 日之间的毫秒数。</p><p>通常我们计算时间差都是通过获取两个时间数据，然后分别使用getTime（）方法返回与固定的1970 年 1 月 1 日的时间差，通过对返回毫秒数的差，换算成时间单位，得出两个时间的时间差。</p><h2 id="开始操作："><a href="#开始操作：" class="headerlink" title="开始操作："></a>开始操作：</h2><p>首先你会有一串初始的时间数据，然后通过 new Date(你的时间数据)，将你的数据<strong>转成Date对象</strong>的形式。</p><pre><code>var t1=&quot;2017/08/28 04:56:38&quot;; //数据var dateBegin = new Date(t1);//转化为Date对象的形式//Mon Aug 28 2017 04:56:38 GMT+0800 (中国标准时间)  这里就是Date对象的数据形式</code></pre><h3 id="时间格式"><a href="#时间格式" class="headerlink" title="时间格式"></a>时间格式</h3><p>这里的话就要注意一下后端给的<strong>时间数据格式</strong>的问题，比如下面两种：</p><pre><code>第一种：&quot;2017/08/28 04:56:38&quot;//这种格式不用再进行处理第二种：&quot;2017-08-01 18:56:38&quot;//这种格式就要进行处理</code></pre><p>因为new Date()方法不能处理第二种数据，所以我们这里需要<strong>将第二种数据格式转化为第一种数据的格式</strong>。</p><pre><code>var t1=&quot;2017-05-12 00:13:53&quot;;var dateBegin = new Date(d1.replace(/-/g, &quot;/&quot;));//replace方法将-转为/</code></pre><p>不知道大家是什么情况，反正因为我们后端给我的数据就是第二种的，所以我会提一下这个东西（捂脸）。</p><h4 id="另一个时间数据"><a href="#另一个时间数据" class="headerlink" title="另一个时间数据:"></a>另一个时间数据:</h4><p>既然是时间差的话，就肯定要有两个数据，不然怎么两相比较，一般两个数据中都会有一个当前时间的数据。</p><pre><code>var dateEnd = new Date();//当前时间数据</code></pre><h3 id="完整计算时间差-天、小时、分钟、秒-的代码："><a href="#完整计算时间差-天、小时、分钟、秒-的代码：" class="headerlink" title="完整计算时间差(天、小时、分钟、秒)的代码："></a>完整计算时间差(天、小时、分钟、秒)的代码：</h3><p>先获取之间的毫秒差，通过毫秒差换算出你所需要的时间单位，然后时间单位之间的换算根据的是他们的倍数关系。</p><pre><code>function timeFn(d1) {//di作为一个变量传进来    //如果时间格式是正确的，那下面这一步转化时间格式就可以不用了    var dateBegin = new Date(d1.replace(/-/g, &quot;/&quot;));//将-转化为/，使用new Date    var dateEnd = new Date();//获取当前时间    var dateDiff = dateEnd.getTime() - dateBegin.getTime();//时间差的毫秒数    var dayDiff = Math.floor(dateDiff / (24 * 3600 * 1000));//计算出相差天数    var leave1=dateDiff%(24*3600*1000)    //计算天数后剩余的毫秒数    var hours=Math.floor(leave1/(3600*1000))//计算出小时数    //计算相差分钟数    var leave2=leave1%(3600*1000)    //计算小时数后剩余的毫秒数    var minutes=Math.floor(leave2/(60*1000))//计算相差分钟数    //计算相差秒数    var leave3=leave2%(60*1000)      //计算分钟数后剩余的毫秒数    var seconds=Math.round(leave3/1000)    console.log(&quot; 相差 &quot;+dayDiff+&quot;天 &quot;+hours+&quot;小时 &quot;+minutes+&quot; 分钟&quot;+seconds+&quot; 秒&quot;)    console.log(dateDiff+&quot;时间差的毫秒数&quot;,dayDiff+&quot;计算出相差天数&quot;,leave1+&quot;计算天数后剩余的毫秒数&quot;        ,hours+&quot;计算出小时数&quot;,minutes+&quot;计算相差分钟数&quot;,seconds+&quot;计算相差秒数&quot;);}var t3=&quot;2017-08-18 04:56:38&quot;;timeFn(t3);</code></pre><p><img src="https://user-gold-cdn.xitu.io/2017/10/15/3ffd4a7df082edd1f1ed6e413cfc35eb" alt="demo时间差数据截图"></p><h3 id="不成熟的计算月、年"><a href="#不成熟的计算月、年" class="headerlink" title="不成熟的计算月、年:"></a>不成熟的计算月、年:</h3><pre><code>//这里的dayDiff就是上文计算出的天数差let monthDiff=Math.floor(dayDiff/30);//以30天为一个月不够精准严谨//获取相差的月份  if (monthDiff&lt;12){    timeThis=monthDiff+&quot;个月前发布&quot;;//获取相差的月份    return  }  let yearDiff=Math.floor(monthDiff/12);//获取相差的年份  if(yearDiff&gt;=1){    timeThis=yearDiff+&quot;年前发布&quot;;    return  }</code></pre><p>当天数相差较大的时候，单纯计算天数已经不能满足需求了，因为我们PM说的统一以30天为一个月的分界线，然后这里月份的计算情况感觉很复杂的样子没有继续研究下去。</p><h3 id="获取当前月份的天数"><a href="#获取当前月份的天数" class="headerlink" title="获取当前月份的天数"></a>获取当前月份的天数</h3><pre><code> function getDays() {    //构造当前日期对象    var date = new Date();    var year = date.getFullYear();//获取年份    var mouth = date.getMonth() + 1;//获取当前月份    var days;//定义当月的天数；    if (mouth == 2) {//当月份为二月时，根据闰年还是非闰年判断天数        days = year % 4 == 0 ? 29 : 28;    }    else if (mouth == 1 || mouth == 3 || mouth == 5 || mouth == 7 || mouth == 8 || mouth == 10 || mouth == 12) {        //月份为：1,3,5,7,8,10,12 时，为大月.则天数为31；        days = 31;    }    else {        //其他月份，天数为：30.        days = 30;    }    return days;}</code></pre><p>网上找了个获取当前月份天数的函数，上面的注释也足够全，我就一起贴上来，连接在下面。</p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>上面就是本文计算时间差的内容了，希望看完本文能给大家一点帮助。最后一个提示：一般需要处理的数据不会只有一两个，很可能会给一个数组，你需要处理每个数组元素的时间数据，这时候建议用forEach()函数遍历整个数组。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><a href="http://obkoro1.com/" target="_blank" rel="external">blog网站</a>  and <strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a> </strong></p><p>以上2017.10.15</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><p><a href="http://www.cnblogs.com/rzm2wxm/p/5749151.html" target="_blank" rel="external">Js 获取当前月的天数</a><br><a href="http://blog.csdn.net/wei_jie_zhang/article/details/45873837" target="_blank" rel="external"> Js计算时间差（天、小时、分钟、秒）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h2&gt;&lt;p&gt;如题，就像题目说的需要计算出时间差，虽然不太难，但这个需求经常会在项目中遇到的，我在这边做一下整理，希望能够尽量全的
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="时间差" scheme="http://yoursite.com/tags/%E6%97%B6%E9%97%B4%E5%B7%AE/"/>
    
  </entry>
  
  <entry>
    <title>vue-cli npm run build空白页的两个坑 webpack gzip文件压缩优化打包文件</title>
    <link href="http://yoursite.com/2017/10/11/vue-cli-npm-run-build%E7%A9%BA%E7%99%BD%E9%A1%B5%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9D%91-webpack-gzip%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96%E6%89%93%E5%8C%85%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2017/10/11/vue-cli-npm-run-build空白页的两个坑-webpack-gzip文件压缩优化打包文件/</id>
    <published>2017-10-11T15:10:07.000Z</published>
    <updated>2017-10-11T15:11:34.680Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>npm run build 是vue-cli用来打包项目的命令行，本文是关于vue-cli打包的一些常见的坑，会尽量详细的写每个步骤，大家可以一边看着文章，一边打包试试。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。</p><h2 id="初始化一个项目："><a href="#初始化一个项目：" class="headerlink" title="初始化一个项目："></a>初始化一个项目：</h2><p>这里初始化一个项目，因为导致打包错误的原因多种多样，避免因为其他设置错误干扰，<strong>从头开始打包整体步骤也会更加清晰</strong>。</p><h3 id="命令行："><a href="#命令行：" class="headerlink" title="命令行："></a>命令行：</h3><pre><code>vue init webpack build1(项目名)//吧啦吧啦进行一波设置//进入项目文件夹npm install</code></pre><p>如果还不清楚如何初始化运行一个项目，可以参考我之前写的一篇文章：<a href="https://juejin.im/post/597eee92f265da3e2e56e37c" target="_blank" rel="external">传送门</a>。</p><h2 id="开始打包踩坑"><a href="#开始打包踩坑" class="headerlink" title="开始打包踩坑"></a>开始打包踩坑</h2><h3 id="命令行：-1"><a href="#命令行：-1" class="headerlink" title="命令行："></a>命令行：</h3><pre><code>//直接打包npm run build</code></pre><h3 id="打包出来的文件"><a href="#打包出来的文件" class="headerlink" title="打包出来的文件"></a>打包出来的文件</h3><p><img src="https://user-gold-cdn.xitu.io/2017/9/26/0324afbbfce9a0baf513417e07292c6b" alt="vue-cli项目文件打包位置"></p><h3 id="第一个坑：文件引用路径"><a href="#第一个坑：文件引用路径" class="headerlink" title="第一个坑：文件引用路径"></a>第一个坑：文件引用路径</h3><p>现在项目我们什么都没动，是初始化之后直接打包的状态，打开dist/index.htmnl文件整个网页都是一片空白的。</p><p><img src="https://user-gold-cdn.xitu.io/2017/9/26/609c0d3e25e99744930d81e892156f0b" alt=""></p><p>打开调试，发现有一排报错说是：<code>不能加载到资源</code>，后面就发现<strong>路径的问题</strong>，仔细看上面再看上面加载的css的引用路径，这里是有问题的。</p><h3 id="爬坑："><a href="#爬坑：" class="headerlink" title="爬坑："></a>爬坑：</h3><p><strong>文件位置：</strong>config文件夹/index.js文件</p><h4 id="1-更改assetsPublicPath属性："><a href="#1-更改assetsPublicPath属性：" class="headerlink" title="1.更改assetsPublicPath属性："></a>1.更改assetsPublicPath属性：</h4><p>文件里面有两个assetsPublicPath属性，更改第一个，也就是更改build里面的assetsPublicPath属性：</p><pre><code>assetsPublicPath:&apos;/&apos;//falseassetsPublicPath:&apos;./&apos;//true</code></pre><p>assetsPublicPath属性作用是指定编译发布的根目录，<strong>‘/‘指的是项目的根目录 ，’./‘指的是当前目录。</strong></p><h4 id="2-改好设置之后，重新打包。"><a href="#2-改好设置之后，重新打包。" class="headerlink" title="2.改好设置之后，重新打包。"></a>2.改好设置之后，重新打包。</h4><p>打开打包文件：</p><p><img src="https://user-gold-cdn.xitu.io/2017/9/26/f4afd954cdb3dc6702dbae4a8066441a" alt="重新打开index.html"></p><h4 id="错误原因："><a href="#错误原因：" class="headerlink" title="错误原因："></a>错误原因：</h4><p><img src="https://user-gold-cdn.xitu.io/2017/9/26/bfc1ccd0318c288369a1d5d914ba16b6" alt="dist文件夹"></p><p>打包出来所有的文件都会放在dist的static文件夹下面，index.html要加载文件，那么问题来了，’/‘指的是项目的根目录 ，’./‘指的是当前目录。要选哪个？当然选择原谅她了。</p><h3 id="第二个坑：路由history模式。"><a href="#第二个坑：路由history模式。" class="headerlink" title="第二个坑：路由history模式。"></a>第二个坑：路由history模式。</h3><p>这个坑是当你使用了路由之后，<strong>在没有后端配合的情况下就手贱打开路由history模式的时候</strong>，打包出来的文件也会是一片空白的情况，很多人踩这个坑的时候花了很多时间，网上的教程基本上都是说的第一个坑，这个坑很少有人提起。</p><p><img src="https://user-gold-cdn.xitu.io/2017/10/9/bafef77c3943e031154d127964508072" alt="图片出自vue-router文档"></p><h4 id="打包之前的样子："><a href="#打包之前的样子：" class="headerlink" title="打包之前的样子："></a>打包之前的样子：</h4><p>这里我弄了个示例，因为是刚创建的项目没有其他因素干扰，当你打开路由的history模式之后，开发的时候一切正常</p><p><img src="https://user-gold-cdn.xitu.io/2017/9/26/28200b7f45b8aac0897f62124c41eec1" alt="打包之前的路由"></p><h4 id="打包之后的样子："><a href="#打包之后的样子：" class="headerlink" title="打包之后的样子："></a>打包之后的样子：</h4><p><img src="https://user-gold-cdn.xitu.io/2017/9/26/f9c56757612f1dd5703fbf0fa09fb155" alt="打包之后路径也是对的，但是页面一片空白"></p><h4 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h4><pre><code>// mode: &apos;history&apos;,//将这个模式关闭就好</code></pre><p>这里并不是说不能打开这个模式，这个模式需要后端设置的配合，详情可以看：<a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="external">路由文档</a></p><hr><h3 id="Gzip-文件压缩"><a href="#Gzip-文件压缩" class="headerlink" title="Gzip 文件压缩"></a>Gzip 文件压缩</h3><p>顺带分享一个很6的优化打包的方法，用起来也简单的很，只要下载一个插件，然后打开一个设置就好了。</p><h4 id="设置方法："><a href="#设置方法：" class="headerlink" title="设置方法："></a>设置方法：</h4><p><img src="https://user-gold-cdn.xitu.io/2017/10/9/1f95faabfb7463e1dce708f046960398" alt=""></p><p>这里其实是webpack自带的一个优化打包的方法，打开这个配置后如果没有下载那个插件，会提示你下载，下载就好了。</p><p>然后在打包的时候，每个js和css文件会压缩一个gz后缀的文件夹，浏览器如果支持g-zip 会自动查找有没有gz文件 找到了就加载gz然后本地解压 执行。</p><p>打开这个配置会之后对整体的打包体积也就是dist文件夹并没有太大的变化。下图来看看他的压缩率以及对加载的提升，可以说是非常大且明显的，大家可以自己试一下就知道多好用了。</p><p><img src="https://user-gold-cdn.xitu.io/2017/10/9/7fd308bb2a27aba49009455266da73d3" alt=""></p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>之前自己打包的时候连着踩了不少坑，可能是互相关联的，有时候你并不是错了一个地方，要想想自己其他地方是不是也是错的。上述的内容，算是自己踩坑的一些经验，希望可以帮到大家。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a> </strong></p><p>以上2017.10.10</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h2&gt;&lt;p&gt;npm run build 是vue-cli用来打包项目的命令行，本文是关于vue-cli打包的一些常见的坑，会尽量
      
    
    </summary>
    
      <category term="vue-cli" scheme="http://yoursite.com/categories/vue-cli/"/>
    
    
      <category term="build空白页" scheme="http://yoursite.com/tags/build%E7%A9%BA%E7%99%BD%E9%A1%B5/"/>
    
      <category term="gzip文件压缩" scheme="http://yoursite.com/tags/gzip%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/"/>
    
  </entry>
  
  <entry>
    <title>vue-cli 自定义路径别名 assets和static文件夹的区别 --save-dev和--save的区别</title>
    <link href="http://yoursite.com/2017/10/11/vue-cli-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D-assets%E5%92%8Cstatic%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E5%8C%BA%E5%88%AB-save-dev%E5%92%8C-save%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2017/10/11/vue-cli-自定义路径别名-assets和static文件夹的区别-save-dev和-save的区别/</id>
    <published>2017-10-11T15:08:48.000Z</published>
    <updated>2017-10-11T15:11:34.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>这是一篇vue-cli的几个小知识点简单介绍，适用于刚接触vue-cli脚手架以及对此方面并不太了解的同学，大佬们绕道。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。</p><h2 id="静态资源处理："><a href="#静态资源处理：" class="headerlink" title="静态资源处理："></a>静态资源处理：</h2><h3 id="assets和static文件夹的区别"><a href="#assets和static文件夹的区别" class="headerlink" title="assets和static文件夹的区别"></a>assets和static文件夹的区别</h3><p>相信有很多人知道vue-cli有两个放置静态资源的地方，分别是<code>src/assets</code>文件夹和<code>static</code>文件夹,这两者的区别很多人可能不太清楚。</p><p><strong>assets目录中的文件会被webpack处理解析为模块依赖</strong>，只支持相对路径形式。例如，在 <code>&lt;img src=&quot;./logo.png&quot;&gt;</code><br>和 <code>background: url(./logo.png)</code>中，”./logo.png” 是相对的资源路径，将由Webpack解析为模块依赖。</p><p><strong>static/ 目录下的文件并不会被Webpack处理：它们会直接被复制到最终的打包目录（默认是dist/static）下。</strong>必须使用绝对路径引用这些文件，这是通过在 config.js 文件中的 build.assetsPublicPath 和 build.assetsSubDirectory 连接来确定的。</p><p>任何放在 static/ 中文件需要以绝对路径的形式引用：/static/[filename]。</p><p>在我们实际的开发中，总的来说：<strong>static放不会变动的文件 assets放可能会变动的文件。</strong></p><h3 id="在js数据中如何引用图片"><a href="#在js数据中如何引用图片" class="headerlink" title="在js数据中如何引用图片"></a>在js数据中如何引用图片</h3><p>因为webpack会将图片当做模块来引用，所以在js中需要使用require将图片引用进来，不能直接以字符串的形式。</p><pre><code>js部分：    data () {        return {             imgUrl: &apos;图片地址&apos;,//错误写法            imgUrl: require(&apos;图片地址&apos;)//正确的写法        }}template部分：img标签形式：&lt;img :src=&quot;img&quot; /&gt;或者div背景图形式：&lt;div :style=&quot;{backgroundImage: &apos;url(&apos; + img + &apos;)&apos;}&quot;&gt;&lt;/div&gt;</code></pre><p>说了图片就正好再提一下vue-cli的一个图片有关的配置，下图这个配置的意思是：在10000b 的图片以下进行base64转换，所以如果项目中有些比较小的icon就不用再进行图片精灵的处理了</p><p><img src="https://user-gold-cdn.xitu.io/2017/9/17/a476773456af2f136aa1e1a45da18f9f" alt=""></p><h2 id="webpack-vue自定义路径别名"><a href="#webpack-vue自定义路径别名" class="headerlink" title="webpack+vue自定义路径别名"></a>webpack+vue自定义路径别名</h2><p>vue-cli 用的是webpack，也可以使用webpack自定义别名这个功能，自定义别名这个功能<strong>当你在多层文件夹嵌套的时候不必一层一层找路径，直接使用自定义别名就可以找到文件的位置。</strong></p><h3 id="设置方法："><a href="#设置方法：" class="headerlink" title="设置方法："></a>设置方法：</h3><p><strong>设置地址：</strong>build文件夹下面的webpack.base.conf.js文件<br><strong>具体设置：</strong></p><pre><code>resolve: {    extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;],     alias: {        &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,        &apos;@&apos;: resolve(&apos;src&apos;),        &apos;static&apos;:path.resolve(__dirname, &apos;../static&apos;),//增加这一行代码        }    },</code></pre><p><strong>使用方式：</strong></p><p>使用的时候要像下方截图的B处一样前面要加上一个’~’，这里的webstorm虽然提示报错，我们可以不用管，代码运行是正常的。</p><p><strong>解读：</strong></p><p>这里给’static’赋予了一个地址，那么在程序中引入路径的时候’~static’就直接可以代替路径’../static’，亲测，这里就算多层嵌套也可以成功找到路径。</p><p><img src="https://user-gold-cdn.xitu.io/2017/9/18/35d8e67e0a4783aba76fde31412225a4" alt="示例图片"></p><h2 id="清理项目中没用的插件"><a href="#清理项目中没用的插件" class="headerlink" title="清理项目中没用的插件"></a>清理项目中没用的插件</h2><p>很多人像我一样，刚开始的会安装很多插件，然后最后在项目中并没有用到。那之前安装的插件太多了，连自己都忘记了安装了哪些插件？</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p><img src="https://user-gold-cdn.xitu.io/2017/9/17/7e9d41302f682760c2eb6cccf5137acf" alt=""></p><p>在上图所示位置，我们项目安装的所有的模块依赖都在这个pageage.json文件中，当我们需要整理一波自己的依赖的时候，可以在这个文件里面找有没有现在已经没用的依赖，可以使用命令行<code>npm remove 模块名字</code>来删除没用的模块。</p><h3 id="–save-dev和–save的区别"><a href="#–save-dev和–save的区别" class="headerlink" title="–save-dev和–save的区别"></a>–save-dev和–save的区别</h3><p>上面的这些依赖有些只在开发环境里面使用的模块，有的在项目上线之后还是要继续依赖的模块。他们之间的区别就在于我们平时安装模块依赖时的：<code>--save-dev</code>和 <code>--save</code></p><p>当你使用<code>--save-dev</code>安装依赖的时候就会放在package.json的devDependencies对象下面，相反的，当你使用<code>--save</code>安装依赖的时候就会出现在dependencies对象下面。</p><p>总结：<strong> –save-dev 是你开发时候依赖的东西，–save 是你发布之后还依赖的东西。</strong></p><h3 id="关于vue-cli配置之前也写过两篇文章，需要的同学可以看一下："><a href="#关于vue-cli配置之前也写过两篇文章，需要的同学可以看一下：" class="headerlink" title="关于vue-cli配置之前也写过两篇文章，需要的同学可以看一下："></a>关于vue-cli配置之前也写过两篇文章，需要的同学可以看一下：</h3><p><a href="https://juejin.im/post/597eee92f265da3e2e56e37c" target="_blank" rel="external">手摸手教你使用vue-cli脚手架</a></p><p><a href="https://juejin.im/post/5986f5c8f265da3e0e1053cf" target="_blank" rel="external">在 vue-cli 脚手架中引用 jQuery、bootstrap 以及使用 sass、less 编写 css</a></p><h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>以上就是这篇文章的内容了，是自己一段时间实践项目的一些小积累，后续还有一些内容，因为项目比较紧，可能会晚点和大家见面。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a> </strong></p><p>以上2017.9.18</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h2&gt;&lt;p&gt;这是一篇vue-cli的几个小知识点简单介绍，适用于刚接触vue-cli脚手架以及对此方面并不太了解的同学，大佬们绕
      
    
    </summary>
    
      <category term="vue-cli" scheme="http://yoursite.com/categories/vue-cli/"/>
    
    
      <category term="vue-cli解析" scheme="http://yoursite.com/tags/vue-cli%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>在 vue-cli 脚手架中引用 jQuery、bootstrap 以及使用 sass、less 编写 css [vue-cli配置入门]</title>
    <link href="http://yoursite.com/2017/10/11/%E5%9C%A8-vue-cli-%E8%84%9A%E6%89%8B%E6%9E%B6%E4%B8%AD%E5%BC%95%E7%94%A8-jQuery%E3%80%81bootstrap-%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8-sass%E3%80%81less-%E7%BC%96%E5%86%99-css-vue-cli%E9%85%8D%E7%BD%AE%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2017/10/11/在-vue-cli-脚手架中引用-jQuery、bootstrap-以及使用-sass、less-编写-css-vue-cli配置入门/</id>
    <published>2017-10-11T15:07:00.000Z</published>
    <updated>2017-10-11T15:11:34.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>本文是<a href="https://juejin.im/post/597eee92f265da3e2e56e37c" target="_blank" rel="external">vue-手摸手教你使用vue-cli脚手架-详细步骤图文解析</a>之后，又一篇关于vue-cli脚手架配置相关的文章，因为有些文章步骤不够清晰，当时我引入JQuery、bootstrap的时候颇费了一番功夫，所以本文的步骤会尽量详细一点。有需要的朋友可以做一下参考，喜欢的可以点波赞，或者关注一下，希望可以帮到大家。</p><h2 id="引入bootstrap"><a href="#引入bootstrap" class="headerlink" title="引入bootstrap"></a>引入bootstrap</h2><h3 id="1-下载所需要的bootstrap文件。"><a href="#1-下载所需要的bootstrap文件。" class="headerlink" title="1. 下载所需要的bootstrap文件。"></a>1. 下载所需要的bootstrap文件。</h3><p>将要使用的bootstrap文件放入src目录下的assets文件夹中。</p><h3 id="2-在入口文件src-main-js中引入bootstrap"><a href="#2-在入口文件src-main-js中引入bootstrap" class="headerlink" title="2. 在入口文件src/main.js中引入bootstrap"></a>2. 在入口文件src/main.js中引入bootstrap</h3><pre><code>import &apos;./assets/bootstrap-3.3.7-dist/css/bootstrap.min.css&apos;import &apos;./assets/bootstrap-3.3.7-dist/js/bootstrap.min&apos;//根据自己文件夹路径选择路径</code></pre><p>这样就可以在vue项目中使用bootstrap的样式了，直接在class中使用即可，如下图按钮样式。</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/7/8fa300c1f5ce01a2a6169b85b3c65717" alt=""></p><hr><h2 id="引入jquery"><a href="#引入jquery" class="headerlink" title="引入jquery"></a>引入jquery</h2><h3 id="1-下载jquery依赖。"><a href="#1-下载jquery依赖。" class="headerlink" title="1. 下载jquery依赖。"></a>1. 下载jquery依赖。</h3><pre><code>npm install jquery --save</code></pre><p>本来我下载的jQuery依赖包，但是出现了一个警告：<br><img src="https://user-gold-cdn.xitu.io/2017/8/6/74dba74724cfd56e67b353f875c39c25" alt=""><br>这里出现了一个警告，意思是说<code>弃用jQuery@1.7.4,请使用“jquery”(全小写)。</code>，然后我就换成全小写的jquery。</p><h3 id="2-修改配置"><a href="#2-修改配置" class="headerlink" title="2. 修改配置"></a>2. 修改配置</h3><ol><li>位置：build文件夹下的webpack.base.conf.js文件。<br> 加入webpack对象：<pre><code>var webpack = require(&quot;webpack&quot;);</code></pre></li><li>位置：build文件夹下的webpack.base.conf.js文件（原来的位置），在下方module.exports对象里面加入。<pre><code> plugins: [// 3. 配置全局使用 jquery    new webpack.ProvidePlugin({    $: &quot;jquery&quot;,    jQuery: &quot;jquery&quot;,    jquery: &quot;jquery&quot;,    &quot;window.jQuery&quot;: &quot;jquery&quot;})],</code></pre><img src="https://user-gold-cdn.xitu.io/2017/8/6/965457674692e42243cec5c8d29683be" alt="如图所示"></li><li>没有第三步，现在已经可以<strong>直接在组件中使用jquery的方法</strong>了，<strong>不用在其他位置引用jquery</strong>，就是这么轻松加愉快。</li></ol><h3 id="3-使用JQ插件"><a href="#3-使用JQ插件" class="headerlink" title="3. 使用JQ插件"></a>3. 使用JQ插件</h3><p>关于这一点查阅了很多资料，几乎没什么文献清楚的说明jq插件的使用方式，以至于很多使用vue很久的大佬们，也不知道jq的插件竟然可以直接在vue-cli中使用。。这一步虽然是简单的，但这里还是提一下，为各位提供一些参考。</p><h3 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h3><p>jq插件只需要将插件所需要的文件下载到本地src/assets或者最外层的static文件夹中，然后将插件的文件引用进组件，根据插件封装的方法来进行调用就行了，跟直接使用jq的插件基本上是一毛一样的。</p><h3 id="下面是一个引用jq插件的demo示例："><a href="#下面是一个引用jq插件的demo示例：" class="headerlink" title="下面是一个引用jq插件的demo示例："></a>下面是一个引用jq插件的demo示例：</h3><p><img src="https://user-gold-cdn.xitu.io/2017/8/7/8482dcb1de93a03dec7ddde5bd1aea6f" alt=""></p><hr><h2 id="关于css的部分"><a href="#关于css的部分" class="headerlink" title="关于css的部分"></a>关于css的部分</h2><p>在vue-cli中使用sass、less来编写css样式，步骤十分简洁，因为vue-cli已经配置好了sass、less，我们要使用sass或者less直接下载两个模块，然后webpack会根据 lang 属性自动用适当的加载器去处理。</p><h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><ol><li>直接上手写样式即可，使用css规则。</li><li>引用外部css文件的写法。<pre><code>&lt;style lang=&quot;css&quot;&gt;@import &apos;./index.css&apos;&lt;/style&gt;或者&lt;style lang=&quot;css&quot; src=&quot;./index.css&quot;&gt;&lt;/style&gt;</code></pre></li></ol><h3 id="如果需要使用sass"><a href="#如果需要使用sass" class="headerlink" title="如果需要使用sass"></a>如果需要使用sass</h3><ol><li>安装sass模块<pre><code>npm install node-sass --save-devnpm install sass-loader --save-dev</code></pre></li><li>在组件的style部分使用内联写法<pre><code>&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;//在这个部分添加lang=&quot;scss&quot;//sass样式&lt;/style&gt;</code></pre></li><li>引用sass外部文件的写法。<pre><code>&lt;style lang=&quot;scss&quot; src=&quot;./index.scss&quot;&gt;&lt;/style&gt;</code></pre></li></ol><h3 id="如果需要使用less"><a href="#如果需要使用less" class="headerlink" title="如果需要使用less"></a>如果需要使用less</h3><ol><li>安装less模块<pre><code>npm install less --save-devnpm install less-loader --save-dev</code></pre></li><li>在组件的style部分使用内联写法<pre><code>&lt;template&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style lang=&quot;less&quot; scoped&gt;//在这个部分添加lang=&quot;less&quot;//less样式&lt;/style&gt;</code></pre></li><li>引用less外部文件的写法。<pre><code>&lt;style lang=&quot;less&quot; src=&quot;./index.less&quot;&gt;&lt;/style&gt;</code></pre></li></ol><hr><h2 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h2><p>仔细阅读，按步骤来基本上可以配置成功。<strong>如果有哪个地方写的不够清楚的，欢迎指正。</strong>本文面向小白，写着玩，大手请轻喷。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！写文偏小白，写的不好之处，欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a> </strong></p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="http://blog.csdn.net/tanhao_282700/article/details/68955607" target="_blank" rel="external"> vue-cli快速构建项目以及引入bootstrap、jq</a><br><a href="http://www.cnblogs.com/xiaofenguo/p/6605302.html" target="_blank" rel="external">vue中引入jQuery和Bootstrap</a><br><a href="http://blog.csdn.net/itKingOne/article/details/74729508" target="_blank" rel="external">Vue-cli单文件组件引入less、sass、css样式的不同方法</a></p><p>以上2017.8.10</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h2&gt;&lt;p&gt;本文是&lt;a href=&quot;https://juejin.im/post/597eee92f265da3e2e56e37
      
    
    </summary>
    
      <category term="vue-cli" scheme="http://yoursite.com/categories/vue-cli/"/>
    
    
      <category term="vue-cli配置" scheme="http://yoursite.com/tags/vue-cli%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>手摸手教你使用vue-cli脚手架-详细步骤图文解析[vue入门]</title>
    <link href="http://yoursite.com/2017/10/11/%E6%89%8B%E6%91%B8%E6%89%8B%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8vue-cli%E8%84%9A%E6%89%8B%E6%9E%B6-%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%E5%9B%BE%E6%96%87%E8%A7%A3%E6%9E%90-vue%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2017/10/11/手摸手教你使用vue-cli脚手架-详细步骤图文解析-vue入门/</id>
    <published>2017-10-11T15:04:43.000Z</published>
    <updated>2017-10-11T15:11:34.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>使用 vue-cli 可以快速创建 vue 项目，vue-cli很好用，但是在最初搭建环境安装vue-cli及相关内容的时候，对一些人来说是很头疼的一件事情，本人在搭建vue-cli的项目环境的时候也是踩了相当多的坑，特此写了一篇搭建环境的教程，每一步尽量详细解析。需要的朋友可以过来参考下，喜欢的可以点波赞，或者关注一下本人，希望可以帮到大家。</p><h2 id="vue-cli脚手架的优势："><a href="#vue-cli脚手架的优势：" class="headerlink" title="vue-cli脚手架的优势："></a>vue-cli脚手架的优势：</h2><ol><li>有一套成熟的vue项目架构设计,能够快速初始化一个Vue项目.</li><li><a href="https://github.com/vuejs/vue-cli" target="_blank" rel="external">vue-cli</a>是官方支持的一个脚手架，会随本版本进行迭代更新。</li><li>vue-cli提供了一套本地的node测试服务器，使用vue-cli自己提供的命令，就可以启动服务器。</li><li>集成打包上线方案。</li><li>还有一些优点，包括：模块化，转译，预处理，热加载，静态检测和自动化测试等，等大家深入使用下去就会发现vue-cli的强大之处。</li></ol><hr><h3 id="本教程是基于windows系统。"><a href="#本教程是基于windows系统。" class="headerlink" title="本教程是基于windows系统。"></a>本教程是基于windows系统。</h3><p>下面正式开始搭建vue-cli脚手架。</p><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><p>命令行工具是我们操作npm的基础，这个必须要有的，很多教程没有写清楚，那些教程一上来就贴上一大堆命令，当初也不知道在哪里使用命令行工具。。。</p><h4 id="git-bash命令行工具"><a href="#git-bash命令行工具" class="headerlink" title="git bash命令行工具"></a>git bash命令行工具</h4><ol><li><p>windows下本人推荐使用GitHub的桌面管理工具自带的git bash命令行工具，正常下载安装就可以。</p></li><li><p><a href="https://desktop.github.com/" target="_blank" rel="external">下载地址</a>，下图是下载安装完成之后，git bash的使用方法。</p></li></ol><p><img src="https://user-gold-cdn.xitu.io/2017/8/1/9a10ec89f6a6613a793f4a8a1f1ed294" alt="git bash命令行工具的使用方法"></p><p>ps:当然如果想使用自带的终端cmd命令行工具也是可以，但是毕竟没有git bash来的好用方便。</p><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><ol><li><p>在<a href="http://nodejs.cn/download/" target="_blank" rel="external">node.js中文官网</a>正常下载安装node.js就可以，没有什么特别需要注意的点（傻瓜式安装）。</p></li><li><p>在官网下载安装node.js后，就已经自带npm（包管理工具），不需要另外再进行安装npm了。</p></li><li><h4 id="注意下载node-js版本要在4-0以上，避免版本过低影响使用。"><a href="#注意下载node-js版本要在4-0以上，避免版本过低影响使用。" class="headerlink" title="注意下载node.js版本要在4.0以上，避免版本过低影响使用。"></a>注意下载node.js版本要在4.0以上，避免版本过低影响使用。</h4></li><li><p>打开命令行工具（随便哪个文件夹），输入命令行 <code>node -v</code>，<code>npm -v</code>，如下图，如果出现相应的版本号，则说明安装成功。</p></li></ol><p><img src="https://user-gold-cdn.xitu.io/2017/8/1/d2f7f37faba936f99a249017e065a3e8" alt="检测node npm安装情"></p><h2 id="安装淘宝镜像"><a href="#安装淘宝镜像" class="headerlink" title="安装淘宝镜像"></a>安装淘宝镜像</h2><h3 id="cnpm（淘宝镜像）相关："><a href="#cnpm（淘宝镜像）相关：" class="headerlink" title="cnpm（淘宝镜像）相关："></a>cnpm（淘宝镜像）相关：</h3><ol><li>这是一个完整 npmjs.org 镜像，是用来<strong>同步npm上面的模块</strong>。</li><li>cnpm的同步频率为 10分钟 （<strong>新发布的模块有滞后性</strong>，同步是需要时间的，等不及的可以使用npm）。</li><li>安装cnpm的原因：npm的服务器是外国的，所以有时候我们安装“模块”会很很慢很慢超级慢。</li><li>cnpm的作用：淘宝镜像将npm上面的模块同步到国内服务器，<strong>提高我们安装模块的时间。</strong></li><li>安装完淘宝镜像之后，<strong><code>cnpm</code>和<code>npm</code>命令行皆可使用，二者并不冲突</strong><br><img src="https://user-gold-cdn.xitu.io/2017/8/3/686a5c34f6c9b89d0b27b16d2378ac77" alt="截图出自淘宝镜像官网"></li></ol><p>安装方法：打开命令行工具，输入命令行：</p><pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>cnpm使用方法:</p><pre><code>$ cnpm install [name]</code></pre><p>安装模块的时候，将npm换成cnpm就行，国内很多coder都是使用cnpm的，个人建议大家都装一下，附上：<a href="http://npm.taobao.org/" target="_blank" rel="external">淘宝镜像网址</a>、</p><h2 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h2><p>安装方法：打开命令行工具，输入命令行：</p><pre><code>npm install webpack -g</code></pre><p>安装成功后输入<code>webpack -v</code>,如果出现相应的版本号，则说明安装成功。</p><h2 id="安装vue-cli脚手架构建工具"><a href="#安装vue-cli脚手架构建工具" class="headerlink" title="安装vue-cli脚手架构建工具"></a>安装vue-cli脚手架构建工具</h2><p>安装方法：全局安装，随便一个文件夹，输入命令行：</p><pre><code>npm install vue-cli -g</code></pre><p>安装完成之后，输入命令行<code>vue -V</code>查看版本号，出现相应得到版本号即为成功：</p><p><img src="https://user-gold-cdn.xitu.io/2017/8/3/eabb4e01fee257f93d466aa9b80d61ee" alt="查看vue-cli是否安装成功"></p><h4 id="注：这里是大写的V"><a href="#注：这里是大写的V" class="headerlink" title="注：这里是大写的V"></a>注：这里是大写的V</h4><h2 id="通过vue-cli，初始化vue项目"><a href="#通过vue-cli，初始化vue项目" class="headerlink" title="通过vue-cli，初始化vue项目"></a>通过vue-cli，初始化vue项目</h2><p>通过以上几步，将我们安装脚手架所需要的环境和工具都准备好好了，下面就可以使用vue-cli来初始化项目。</p><h3 id="1。新建一个vuetext（项目名）文件夹来放置项目，"><a href="#1。新建一个vuetext（项目名）文件夹来放置项目，" class="headerlink" title="1。新建一个vuetext（项目名）文件夹来放置项目，"></a>1。新建一个vuetext（项目名）文件夹来放置项目，</h3><p>在<strong>新建文件夹的上一级文件夹</strong>右键打开命令行工具，输入命令行：</p><pre><code>vue init webpack vuetext1(项目名)</code></pre><p><strong>注：</strong>项目名不能大写，不能使用中文<br>解释一下这个命令，这个命令的意思是<strong>初始化一个vue项目</strong>，其中webpack是构建工具，也就是整个项目是<strong>基于webpack</strong>的。其中vuetext1是整个项目文件夹的名称，这个<strong>文件夹会自动生成在你指定的目录</strong>中。</p><h3 id="2。以下是脚手架安装过程（安装步骤解析在图片下面）"><a href="#2。以下是脚手架安装过程（安装步骤解析在图片下面）" class="headerlink" title="2。以下是脚手架安装过程（安装步骤解析在图片下面）"></a>2。以下是脚手架安装过程（安装步骤解析在图片下面）</h3><p><img src="https://user-gold-cdn.xitu.io/2017/8/4/8d84c6de896ece8579089b8351d8cfb3" alt=""></p><h3 id="vue-cli初始化项目选项配置详细解析"><a href="#vue-cli初始化项目选项配置详细解析" class="headerlink" title="vue-cli初始化项目选项配置详细解析"></a>vue-cli初始化项目选项配置详细解析</h3><pre><code>$ vue init webpack vuetext1--------------------- 安装vue-cli,初始化vue项目的命令? Target directory exists. Continue? (Y/n) y---------------------找到了vuetext1这个目录是否要继续? Target directory exists. Continue? Yes? Project name (vuetext1)---------------------项目的名称（默认是文件夹的名称），ps：项目的名称不能有大写，不能有中文，否则会报错? Project name vuetext1? Project description (A Vue.js project)---------------------项目描述，可以自己写? Project description A Vue.js project? Author (OBKoro1)---------------------项目创建者? Author OBKoro1? Vue build (Use arrow keys)--------------------选择打包方式，有两种方式（runtime和standalone），使用默认即可? Vue build standalone? Install vue-router? (Y/n) y--------------------是否安装路由，一般都要安装? Install vue-router? Yes? Use ESLint to lint your code? (Y/n) n---------------------是否启用eslint检测规则，这里个人建议选no，因为经常会各种代码报错，新手还是不安装好? Use ESLint to lint your code? No? Setup unit tests with Karma + Mocha? (Y/n)--------------------是否安装单元测试? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? (Y/n) y)--------------------是否安装e2e测试? Setup e2e tests with Nightwatch? Yesvue-cli · Generated &quot;vuetext1&quot;.To get started:)--------------------如何开始 cd vuetext1)--------------------进入你安装的项目 npm install)--------------------安装项目依赖 npm run dev)--------------------运行项目Documentation can be found at https://vuejs-templates.github.io/webpack)--------------------vue-cli官方文档</code></pre><p>现在vuetext1项目已经初步初始化完成了，里面也有一些文件，但是现在还不能成功运行。</p><h3 id="3-如何运行项目"><a href="#3-如何运行项目" class="headerlink" title="3.如何运行项目"></a>3.如何运行项目</h3><ol><li>进入你刚才创建在vuetext1项目的文件夹里面，<strong>在vuetext1项目的文件夹里面右键运行git bash 命令行工具</strong>。</li><li><p><strong>安装项目依赖。</strong>命令行： <code>npm  install</code>。前面在项目初始化的时候，已经存在了package.json文件，直接使用npm install 安装项目所需要的依赖，否则项目不能正确运行。</p><h3 id="创建完成的“vuetext1”目录如下："><a href="#创建完成的“vuetext1”目录如下：" class="headerlink" title="创建完成的“vuetext1”目录如下："></a>创建完成的“vuetext1”目录如下：</h3><p><img src="https://user-gold-cdn.xitu.io/2017/8/5/9d766e8dc72c4e9ce241f8ba2ec3618b" alt="创建完成的项目结构"></p></li><li><p>到这里，我们已经成功使用vue-cli初始化了一个vue项目。</p><h4 id="启动项目："><a href="#启动项目：" class="headerlink" title="启动项目："></a>启动项目：</h4><p>在vuetext1目录运行命令行<code>npm run dev</code>，启动服务，服务启动成功后浏览器会默认打开一个“欢迎页面”，如下图。</p></li></ol><p><img src="https://user-gold-cdn.xitu.io/2017/8/5/c1c35aec19a4cd9ea6b587b93720a4e2" alt="vue-cli项目成功启动"></p><p><strong>注意：</strong>这里是默认服务启动的是本地的8080端口，所以请确保你的8080端口不被别的程序所占用，当有其他vue项目运行的时候，可以使用ctrl+c来中断运行。</p><h3 id="vue-cli配置相关"><a href="#vue-cli配置相关" class="headerlink" title="vue-cli配置相关:"></a>vue-cli配置相关:</h3><p>这是我写的另外一篇关于vue-cli配置相关的文章，有需要的朋友可以参考一下。<br><a href="https://juejin.im/post/5986f5c8f265da3e0e1053cf" target="_blank" rel="external">在vue-cli脚手架中引用JQuery、bootstrap以及使用sass、less编写css[vue-cli配置入门]</a></p><h2 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h2><p>本文关于如何搭建vue-cli脚手架已经尽量详细了，仔细阅读，按步骤来基本上可以成功。如果有哪个地方写的不够清楚的，欢迎指正。本文面向小白，写着玩，大手请轻喷。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！写文偏小白，写的不好之处，欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a> </strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h2&gt;&lt;p&gt;使用 vue-cli 可以快速创建 vue 项目，vue-cli很好用，但是在最初搭建环境安装vue-cli及相关内
      
    
    </summary>
    
      <category term="vue-cli" scheme="http://yoursite.com/categories/vue-cli/"/>
    
    
      <category term="初始化vue-cli" scheme="http://yoursite.com/tags/%E5%88%9D%E5%A7%8B%E5%8C%96vue-cli/"/>
    
  </entry>
  
  <entry>
    <title>angular ui-router：简单的单页面嵌套路由的实现过程</title>
    <link href="http://yoursite.com/2017/10/11/angular-ui-router%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/10/11/angular-ui-router：简单的单页面嵌套路由的实现过程/</id>
    <published>2017-10-11T14:58:03.000Z</published>
    <updated>2017-10-11T15:03:25.625Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>ui-router是angular的一个插件，因为angular前面几个版本自带的原生ng-router不能很好的满足开发需求，所以在实现angular单页面嵌套的时候，都是使用ui-router。本文是的内容关于angular ui-router实现过程，内含demo以及代码地址，需要的朋友可以过来参考下，喜欢的可以点波赞，或者关注一下本人，ui-router的实现过程并不复杂，希望通过本文大家能够学会ui-router的使用方法。</p><h2 id="ui-router与ng-router："><a href="#ui-router与ng-router：" class="headerlink" title="ui-router与ng-router："></a>ui-router与ng-router：</h2><p>UI-Router是angular原生ng-route进化版，相较与ng-router有如下两条优点：</p><ol><li><p>视图不能嵌套,这意味着$scope会发生不必要的重新载入。</p></li><li><p>同一URL下不支持多个视图。这一需求也是常见的：我们希望导航栏用一个视图（和相应的控制器）、内容部分用另一个视图（和相应的控制器）。</p></li></ol><h2 id="最终实现demo效果"><a href="#最终实现demo效果" class="headerlink" title="最终实现demo效果"></a>最终实现demo效果</h2><p><img src="https://dn-mhke0kuv.qbox.me/1035fc96102e99ed0631.gif" alt=""></p><h2 id="AngularJS单页面实现原理："><a href="#AngularJS单页面实现原理：" class="headerlink" title="AngularJS单页面实现原理："></a>AngularJS单页面实现原理：</h2><p>AngularJS 路由允许我们通过不同的 URL 访问不同的内容，通常我们的<strong>URL形式</strong>为<a href="http://runoob.com/first/page" target="_blank" rel="external">http://runoob.com/first/page</a> ，在单页Web应用中 AngularJS 通过<strong> # + 标记 </strong>实现，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">http://runoob.com/#/first</div><div class="line">http://runoob.com/#/second</div><div class="line">http://runoob.com/#/third</div></pre></td></tr></table></figure><ol><li>当我们访问这上面任意一个链接的时候，向服务端<strong>请求的都是同一个地址</strong>： <a href="http://runoob.com/" target="_blank" rel="external">http://runoob.com/</a></li><li><strong>#号之后的内容</strong>在向服务端请求时会<strong>被浏览器忽略掉</strong></li><li><p>路由就通过<strong> # + 标记</strong>帮助我们<strong>区分不同的逻辑页面并将不同的页面绑定到对应的控制器上</strong>，如下图所示：</p><p><img src="https://dn-mhke0kuv.qbox.me/6fe0883403f7cb72acd7" alt="不同的视图页面对应不同的控制器"></p></li></ol><h3 id="demo地址"><a href="#demo地址" class="headerlink" title="demo地址"></a><a href="https://obkoro1.github.io/article-demo/2017/uiRouter/index.html#/PageTab/Page3" target="_blank" rel="external">demo地址</a></h3><hr><h1 id="ui-router实现过程"><a href="#ui-router实现过程" class="headerlink" title="ui-router实现过程"></a>ui-router实现过程</h1><h2 id="1、创建页面："><a href="#1、创建页面：" class="headerlink" title=" 1、创建页面："></a> 1、创建页面：</h2><p>要实现上文那个demo效果，我们需要创建如下页面：</p><ol><li>app.js<br> 这是路由的配置页面</li><li>index.html<br> 通常叫做index.html是单页面的首页，里面导入了各种css样式、库，插件，框架之类的。</li><li>PageTab.html<br> 进入index.html首先展示的视图页面，下面几个是PageTab下面的嵌套页面</li><li>Page-1.html</li><li>Page-2.html</li><li>Page-3.html</li></ol><p>代码上传到github上面了，需要的朋友可以自行查看： <a href="https://github.com/OBKoro1/article-demo/tree/master/2017/uiRouter" target="_blank" rel="external">代码地址</a></p><p><strong>注：</strong>angular用的是：1.4.6，ui-router用的是1.0</p><p>ps：现在angular4，自带的原生ng-router好像也已经支持了多层嵌套。但是因为还没流传开，市面上，大多还是1.4，所以还是需要用到ui-router。</p><h2 id="2、在index-html里面导入js文件"><a href="#2、在index-html里面导入js文件" class="headerlink" title=" 2、在index.html里面导入js文件"></a> 2、在index.html里面导入js文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;https://cdn.bootcss.com/angular.js/1.4.6/angular.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;https://cdn.bootcss.com/angular-ui-router/1.0.0-rc.1/angular-ui-router.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script src=&quot;App.js&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure><p>1.angular文件，2.ui-router插件,3.路由js页面</p><h4 id="注意：angular文件必须在ui-router前面，因为ui-router是依赖angular的插件。"><a href="#注意：angular文件必须在ui-router前面，因为ui-router是依赖angular的插件。" class="headerlink" title="注意：angular文件必须在ui-router前面，因为ui-router是依赖angular的插件。"></a>注意：angular文件必须在ui-router前面，因为ui-router是依赖angular的插件。</h4><p>这几个文件是最基本的页面，如果是一个<strong>完整的angular单页面项目</strong>的话，<strong>index,html</strong>是这幅样子：</p><p><img src="https://dn-mhke0kuv.qbox.me/a7e76d330ad49be344e8" alt=""></p><p>在单页面中，不管你从哪个视图查看网页代码，都是这样子，第一次看的都醉了！</p><h2 id="3-app-js"><a href="#3-app-js" class="headerlink" title=" 3.app.js"></a> 3.app.js</h2><p><strong>app.js声明了AngularJS模块和路由配置</strong>。当页面加载的时候我们会在index.html中显示PageTab.html的内容。具体代码如下，每一个关键的地方都有相应的<strong>注释注释注释</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var myApp = angular.module(&quot;myApp&quot;, [&quot;ui.router&quot;]);</div><div class="line">//这里叫做App模块，这将告诉HTML页面这是一个AngularJS作用的页面，并把ui-router注入AngularJS主模块，它的内容由AngularJS引擎来解释。</div><div class="line">myApp.config(function ($stateProvider, $urlRouterProvider) &#123;</div><div class="line">    //这一行声明了把 $stateProvider 和 $urlRouteProvider 路由引擎作为函数参数传入，这样我们就可以为这个应用程序配置路由了.</div><div class="line">    $urlRouterProvider.when(&quot;&quot;, &quot;/PageTab&quot;);</div><div class="line">    //如果没有路由引擎能匹配当前的导航状态，默认将路径路由至 PageTab.html, 那它就像switch case语句中的default选项.就是一个默认的视图选项</div><div class="line">    $stateProvider</div><div class="line">        //这一行定义了会在main.html页面第一个显示出来的状态（就是进入页面先加载的html），作为页面被加载好以后第一个被使用的路由.</div><div class="line">        .state(&quot;PageTab&quot;, &#123;//导航用的名字</div><div class="line">            url: &quot;/PageTab&quot;,//#+标识符，这里就是url地址栏上面的标识符，通过标识符，进入不同的html页面</div><div class="line">            templateUrl: &quot;PageTab.html&quot;//这里是html的路径，这是跟标识符相对应的html页面</div><div class="line">        &#125;)</div><div class="line">        .state(&quot;PageTab.Page1&quot;, &#123;//引号里面代表Page1是PageTab的子页面，用.隔开</div><div class="line">            url:&quot;/Page1&quot;,</div><div class="line">            templateUrl: &quot;Page-1.html&quot;</div><div class="line">        &#125;)</div><div class="line">        .state(&quot;PageTab.Page2&quot;, &#123;//需要跳转页面的时候，就是用这双引号里面的地址</div><div class="line">            url:&quot;/Page2&quot;,</div><div class="line">            templateUrl: &quot;Page-2.html&quot;</div><div class="line">        &#125;)</div><div class="line">        .state(&quot;PageTab.Page3&quot;, &#123;</div><div class="line">            url:&quot;/Page3&quot;,</div><div class="line">            templateUrl: &quot;Page3.html&quot;</div><div class="line">        &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>现在已经成功把appjs实现出来，然后需要在html里面定义视图，以及视图跳转链接</p><h2 id="4-html定义视图"><a href="#4-html定义视图" class="headerlink" title=" 4.html定义视图"></a> 4.html定义视图</h2><p>现在要把我们写好的html视图页面在页面中展示出来，我们来看看index.html里面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;body data-ng-app=&quot;myApp&quot;&gt;</div><div class="line">&lt;!--ui-router的html代码--&gt;</div><div class="line">&lt;div data-ui-view=&quot;&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;!--这里要引入上面说的文件--&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;html&gt;</div></pre></td></tr></table></figure></p><h4 id="在ui-view-””的双引号里面，ui-view展示的页面是根据app-js设置的url对应的html来展示的。"><a href="#在ui-view-””的双引号里面，ui-view展示的页面是根据app-js设置的url对应的html来展示的。" class="headerlink" title="在ui-view=””的双引号里面，ui-view展示的页面是根据app.js设置的url对应的html来展示的。"></a>在ui-view=””的双引号里面，ui-view展示的页面是根据app.js设置的url对应的html来展示的。</h4><h3 id="嵌套页面跳转："><a href="#嵌套页面跳转：" class="headerlink" title="嵌套页面跳转："></a>嵌套页面跳转：</h3><ol><li><p>导航里面的名字必须是“<strong>父页面的名字.子页面的名字</strong>”<br>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.state(&quot;PageTab&quot;, &#123;//这里是名字</div><div class="line">          url: &quot;/PageTab&quot;,</div><div class="line">          templateUrl: &quot;PageTab.html&quot;</div><div class="line">      &#125;)</div><div class="line">      .state(&quot;PageTab.Page1&quot;, &#123;//意思是PageTab视图下面的Page1视图</div><div class="line">          url:&quot;/Page1&quot;,</div><div class="line">          templateUrl: &quot;Page-1.html&quot;</div><div class="line">      &#125;)</div></pre></td></tr></table></figure></li><li><p>在html里面，用<strong>ui-sref</strong>进行跳转<br> demo代码栗子：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">       &lt;h1&gt;下面这几个按钮是在主页面下面再嵌套一层的页面&lt;/h1&gt;</div><div class="line">       &lt;!--ui-sref跳转--&gt;</div><div class="line">       &lt;span style=&quot;width:100px&quot; ui-sref=&quot;.Page1&quot;&gt;&lt;a href=&quot;&quot;&gt;Page-1&lt;/a&gt;&lt;/span&gt;</div><div class="line">       &lt;span style=&quot;width:100px&quot; ui-sref=&quot;.Page2&quot;&gt;&lt;a href=&quot;&quot;&gt;Page-2&lt;/a&gt;&lt;/span&gt;</div><div class="line">       &lt;span style=&quot;width:100px&quot; ui-sref=&quot;.Page3&quot;&gt;&lt;a href=&quot;&quot;&gt;Page-3&lt;/a&gt;&lt;/span&gt;</div><div class="line">   &lt;/div&gt;</div><div class="line">   &lt;div&gt;</div><div class="line">       &lt;!--PageTap嵌套的视图html展示的地方--&gt;</div><div class="line">       &lt;div ui-view=&quot;&quot;/&gt;</div><div class="line">   &lt;/div&gt;</div></pre></td></tr></table></figure></li></ol><p>如果觉得不太明白可以点击下面的代码地址，将代码复制到本地，自己多试一试，应该就明白了：<br><a href="https://obkoro1.github.io/article-demo/2017/uiRouter/index.html#/PageTab/Page3" target="_blank" rel="external">demo地址</a>、<a href="https://github.com/OBKoro1/article-demo/tree/master/2017/uiRouter" target="_blank" rel="external">demo代码地址</a></p><hr><h2 id="写在后面："><a href="#写在后面：" class="headerlink" title="写在后面："></a>写在后面：</h2><p>现在只是一个最简单的使用方式，本来想在写一些深一点的使用方式（内容：路由的其他参数、路由懒加载引用文件、路由视图页面传递参数），写了好久，结果发现还是需要demo结合起来写，比较清楚，等我写好了在下面加个链接。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！因为我经常看不懂别人写的分享，所以个人写文比较偏小白，写的不好之处，欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><strong>ps</strong>：目前<strong>待业</strong>，<strong>城市：杭州/北京（纠结中）</strong>，本人适应互联网快节奏，高强度的工作状态，认真，严谨，学习积极性强。<strong>中小公司大佬求带走</strong>，邮箱：obkoro1@foxmail.com。<br><strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a> </strong></p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p><a href="http://www.runoob.com/angularjs/angularjs-routing.html" target="_blank" rel="external">AngularJS 路由,菜鸟教程</a><br><a href="http://blog.csdn.net/zcl_love_wx/article/details/52034193" target="_blank" rel="external">深究AngularJS——ui-router详解</a>\<br><a href="http://www.oschina.net/translate/angularjs-ui-router-nested-routes" target="_blank" rel="external">AngularJS ui-router (嵌套路由)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h2&gt;&lt;p&gt;ui-router是angular的一个插件，因为angular前面几个版本自带的原生ng-router不能很好的满
      
    
    </summary>
    
      <category term="angular" scheme="http://yoursite.com/categories/angular/"/>
    
    
      <category term="angular ui-router" scheme="http://yoursite.com/tags/angular-ui-router/"/>
    
  </entry>
  
  <entry>
    <title>小白来实现一个Ajax请求[Ajax使用方法及相关知识点详细解析——超级全]</title>
    <link href="http://yoursite.com/2017/10/11/%E5%B0%8F%E7%99%BD%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAAjax%E8%AF%B7%E6%B1%82-Ajax%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E8%B6%85%E7%BA%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2017/10/11/小白来实现一个Ajax请求-Ajax使用方法及相关知识点详细解析——超级全/</id>
    <published>2017-10-11T14:56:14.000Z</published>
    <updated>2018-01-03T02:34:07.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面："><a href="#写在前面：" class="headerlink" title="写在前面："></a>写在前面：</h2><p>本文主要总结整理Ajax使用方法背景知识点的详细解析，以及Ajax跨域的具体使用方式并且对栗子进行了讲解，需要的朋友可以过来参考下，喜欢的可以点波赞，或者关注一下本人，希望通过本文能够作为一个Ajax的查找资料，不懂Ajax？看这篇文章就可以了。</p><h2 id="ajax简介："><a href="#ajax简介：" class="headerlink" title="ajax简介："></a>ajax简介：</h2><ul><li>Ajax 的全称是Asynchronous JavaScript and XML，意思是：异步 JavaScript 和 XML</li><li>Ajax是使用XMLHttpRequest对象与服务器端通信的脚本语言</li><li>可以发送及接收各种格式的信息，包括JSON、XML、HTML和文本文件。</li><li>AJAX可以无需刷新页面而与服务器端进行通信。</li><li>允许你根据用户事件来更新部分页面内容。</li></ul><h2 id="Ajax工作原理："><a href="#Ajax工作原理：" class="headerlink" title="Ajax工作原理："></a>Ajax工作原理：</h2><p>Ajax的工作原理相当于<strong>在用户和服务器之间加了一个中间层(Ajax引擎),使用户操作与服务器响应异步化</strong>。并不是所有的用户请求都提交给服务器,像—些数据验证(比如判断用户是否输入了数据)和数据处理(比如判断用户输入数据是否是数字)等都交给Ajax引擎自己来做, 只有确定<strong>需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求</strong>。把这些交给了Ajax引擎，用户操作起来也就感觉更加流畅了。</p><h2 id="Ajax的优点："><a href="#Ajax的优点：" class="headerlink" title="Ajax的优点："></a>Ajax的优点：</h2><ol><li><p>页面无刷新，用户体验好。</p><ul><li>AJAX最大优点就是能在不刷新整个页面的前提下与服务器通信维护数据。这使得Web应用程序更为迅捷地响应用户交互，并避免了在网络上发送那些没有改变的信息，减少用户等待时间，带来非常好的用户体验。</li></ul></li><li><p>异步通信，更加快的响应能力。</p><ul><li>AJAX使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。优化了Browser和Server之间的沟通，减少不必要的数据传输、时间及降低网络上数据流量。</li></ul></li><li><p>减少冗余请求，减轻了服务器负担</p><ul><li>AJAX的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能。  </li></ul></li><li><p>基于标准化的并被广泛支持的技术，不需要下载插件或者小程序</p><ul><li>AJAX基于标准化的并被广泛支持的技术，不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。</li></ul></li><li>界面与应用分离。 <ul><li>Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。</li></ul></li></ol><h2 id="Ajax应用场景："><a href="#Ajax应用场景：" class="headerlink" title="Ajax应用场景："></a>Ajax应用场景：</h2><ul><li>数据验证。用户的注册，登录功能，通过与后台交互数据，进行数据验证</li><li>按需取数据。按照需求，展示所需要的部分数据，而不是一股脑的将整个网页全都展示出来。</li><li>自动更新页面。栗子：百度搜索的提示,出现联想提示语，展示用户最有可能搜索的词汇。</li><li>自动更新页面。栗子：在线聊天室，设置一个定时器，每隔几秒向请求数据，实时更新页面信息。</li></ul><h3 id="同步执行和异步执行。"><a href="#同步执行和异步执行。" class="headerlink" title="同步执行和异步执行。"></a>同步执行和异步执行。</h3><p>javascript同步表示sync，指的就是：代码依次执行。javascript 异步表示async，指：代码执行不按顺序，可以这么理解：同步是在一条直线上的队列，异步不在一个队列上 各走各的。javascript所谓的“线程”，就是这样的一种概念。</p><p>虽然异步执行可以<strong>实现多任务并行执行</strong>，使执行的效率大大提高，但是异步执行也会<strong>占用浏览器的性能</strong>，不要胡乱的使用异步执行。</p><p>举个栗子：在负荷很重的客户/服务器系 统中，时间延迟频繁且漫长，在这种环境下就比较适宜宜采用异步执行模式。</p><p>关于同步和异步，大概只能说这些，有兴趣的朋友可以自己深入了解一下。</p><hr><h1 id="开始一个Ajax请求需要了解的背景知识："><a href="#开始一个Ajax请求需要了解的背景知识：" class="headerlink" title="开始一个Ajax请求需要了解的背景知识："></a>开始一个Ajax请求需要了解的背景知识：</h1><h2 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象:"></a>XMLHttpRequest对象:</h2><p><strong>Ajax的核心是XMLHttpRequest对象</strong>，它是Ajax实现的关键，发送异步请求、接受响应以及执行回调都是通过它来完成，下面我们就来聊一聊XMLHttpRequest对象是什么鬼？拥有哪些属性、方法，这些都是用来干什么的，这对于我们系统性的了解Ajax请求是非常有帮助的。</p><h2 id="XMLHttpRequest对象的属性："><a href="#XMLHttpRequest对象的属性：" class="headerlink" title="XMLHttpRequest对象的属性："></a>XMLHttpRequest对象的属性：</h2><p><img src="https://dn-mhke0kuv.qbox.me/3210e9b464b7a2e6ae3b" alt="XMLHttpRequest对象的属性"></p><h2 id="XMLHttpRequest对象的方法："><a href="#XMLHttpRequest对象的方法：" class="headerlink" title="XMLHttpRequest对象的方法："></a>XMLHttpRequest对象的方法：</h2><p><img src="https://dn-mhke0kuv.qbox.me/5e62e2775f857c5ee426" alt="XMLHttpRequest对象的方法"></p><p><a href="https://juejin.im/entry/583a9e02ac502e006c214b81" target="_blank" rel="external">图片出处</a></p><p>XMLHttpRequest虽然目前还没有被W3C所采纳，但是它已经是一个事实的标准，因为所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均支持 XMLHttpRequest 对象。，XMLHttpRequest对象的使用方式极其简单，先不要懵逼。继续往下看。</p><h2 id="Ajax的跨域请求由哪些部分组成的"><a href="#Ajax的跨域请求由哪些部分组成的" class="headerlink" title="Ajax的跨域请求由哪些部分组成的"></a>Ajax的跨域请求由哪些部分组成的</h2><ul><li><strong>HTTP请求的方法或动作</strong>，Ajax请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。</li><li>你<strong>需要请求的URL</strong>,总得告诉服务器请求的地址是什么吧?</li><li><strong>请求头</strong>,包含一些客户端环境信息,身份验证信息等</li><li><strong>请求体</strong>,也就是请求正文,请求正文中可以包含客户端提交的查询字符串信息,表单信息等等.</li></ul><h3 id="GET和POST两种请求方式对比："><a href="#GET和POST两种请求方式对比：" class="headerlink" title="GET和POST两种请求方式对比："></a>GET和POST两种请求方式对比：</h3><p><img src="https://dn-mhke0kuv.qbox.me/55cec81020363c5a0499" alt=""></p><p>在前后端分离的情况下，对于前端的小伙伴来说，一般是后端选择请求接口，请求方式，让我们去使用，所以请求方式的选择这点，稍微了解一下即可。</p><h2 id="Ajax的跨域请的回复：http响应："><a href="#Ajax的跨域请的回复：http响应：" class="headerlink" title="Ajax的跨域请的回复：http响应："></a>Ajax的跨域请的回复：http响应：</h2><ul><li>一个数字和文字组成的状态码,用来显示请求是成功还是失败</li><li>响应头,响应头和请求头一样包含许多有用的信息,例如服务器类型,日期时间,内容类型和长度等.</li><li>响应体,也就是响应正文.</li></ul><h3 id="服务器端返回的：常见的HTTP状态码"><a href="#服务器端返回的：常见的HTTP状态码" class="headerlink" title="服务器端返回的：常见的HTTP状态码"></a>服务器端返回的：常见的HTTP状态码</h3><p><img src="https://dn-mhke0kuv.qbox.me/90fcc69d12c28cba1338" alt=""></p><p>关于http的状态码还有非常多，不止上图这点这么简单，有兴趣的可以看本人之前写的一篇文章：<a href="https://juejin.im/post/590082e6a22b9d0065be1a5c" target="_blank" rel="external">http状态码详解</a>。</p><hr><h1 id="如何使用Ajax"><a href="#如何使用Ajax" class="headerlink" title="如何使用Ajax"></a>如何使用Ajax</h1><h3 id="本文中的栗子采用菜鸟教程ajax的栗子：ajax实例"><a href="#本文中的栗子采用菜鸟教程ajax的栗子：ajax实例" class="headerlink" title="本文中的栗子采用菜鸟教程ajax的栗子：ajax实例"></a>本文中的栗子采用菜鸟教程ajax的栗子：<a href="http://www.runoob.com/ajax/ajax-xmlhttprequest-send.html" target="_blank" rel="external">ajax实例</a></h3><h2 id="实现Ajax的四个步骤："><a href="#实现Ajax的四个步骤：" class="headerlink" title="实现Ajax的四个步骤："></a>实现Ajax的四个步骤：</h2><ol><li>新建一个XMLHttpRequest对象。</li><li>open方法表示初始化请求，此时并没有发送。</li><li>定义数据返回后的回调函数，里面的代码在readystatechange值改变的时候执行。</li><li>发送请求。</li></ol><h3 id="使用Ajax的一个栗子，里面注释的也较为详细："><a href="#使用Ajax的一个栗子，里面注释的也较为详细：" class="headerlink" title="使用Ajax的一个栗子，里面注释的也较为详细："></a>使用Ajax的一个栗子，里面注释的也较为详细：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function loadXMLDoc()</div><div class="line">&#123;//点击事件</div><div class="line">  var xmlhttp;</div><div class="line">  if (window.XMLHttpRequest)</div><div class="line">  &#123;</div><div class="line">    // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</div><div class="line">    xmlhttp=new XMLHttpRequest();</div><div class="line">  &#125;</div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">    // IE6, IE5 浏览器执行代码</div><div class="line">    xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</div><div class="line">  &#125;</div><div class="line"> //1、上面是创建XMLHttpRequest对象</div><div class="line">  xmlhttp.open(&quot;POST&quot;,&quot;/try/Ajax/demo_post2.php&quot;,true);// 2、open方法表示初始化请求，此时并没有发送。</div><div class="line">  xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</div><div class="line">  xmlhttp.send(&quot;fname=Henry&amp;lname=Ford&quot;);//4、发送请求</div><div class="line">  xmlhttp.onreadystatechange=function();</div><div class="line">  &#123;//3、当参数被传入服务器的时候，引用监听事件。</div><div class="line">    if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200)</div><div class="line">    //判断readyState四种状态，当执行四步完成之后，并且返回的是200（成功）</div><div class="line">    &#123;</div><div class="line">      document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="1、新建一个XMLHttpRequest对象："><a href="#1、新建一个XMLHttpRequest对象：" class="headerlink" title="1、新建一个XMLHttpRequest对象："></a>1、新建一个XMLHttpRequest对象：</h3><p>XMLHttpRequest对象在上文介绍了他的属性和方法，如上所述， Ajax的核心是XMLHttpRequest对象，这一步是必不可少的，下面就是它的使用语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var xmlhttp = new XMLHttpRequest();//没看错，就是这么简单</div></pre></td></tr></table></figure><h3 id="Ajax兼容IE7以下："><a href="#Ajax兼容IE7以下：" class="headerlink" title="Ajax兼容IE7以下："></a>Ajax兼容IE7以下：</h3><p>XMLHttpRequest对象是IE7才开始支持的，老版本IE5和IE6使用的是ActiveX 对象，使用方式是一样的，区别在于要创建不同的对象。<strong>IE7以上自带XMLHttpRequest对象，如果要兼容IE5和IE6只需判断浏览器中是否存在XMLHttpRequest对象。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var xmlhttp;</div><div class="line">  if (window.XMLHttpRequest)//检查是否有XMLHttpRequest对象</div><div class="line">  &#123;</div><div class="line">    // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</div><div class="line">    xmlhttp=new XMLHttpRequest();</div><div class="line">  &#125;</div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">    // IE6, IE5 浏览器执行代码</div><div class="line">    xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure><h3 id="2、open方法表示初始化请求，此时并没有发送。"><a href="#2、open方法表示初始化请求，此时并没有发送。" class="headerlink" title="2、open方法表示初始化请求，此时并没有发送。"></a>2、open方法表示初始化请求，此时并没有发送。</h3><p>open方法的语法<code>open(method,url,async)</code></p><ol><li>参数一：method——请求方式，get或者post。（默认为get）</li><li>参数二：url——请求路径,文件在服务器上的位置</li><li>参数三：async——true：异步请求。false:同步请求。（默认为true，异步请求。）</li></ol><h3 id="3-定义数据返回后的回调函数，里面的代码在readystatechange值改变的时候执行。"><a href="#3-定义数据返回后的回调函数，里面的代码在readystatechange值改变的时候执行。" class="headerlink" title="3.定义数据返回后的回调函数，里面的代码在readystatechange值改变的时候执行。"></a>3.定义数据返回后的回调函数，里面的代码在readystatechange值改变的时候执行。</h3><p>触发Ajax的时候，XMLHttpRequest 的状态会不断变化，这个值就存在readyState属性中。</p><h4 id="readyState属性："><a href="#readyState属性：" class="headerlink" title="readyState属性："></a>readyState属性：</h4><p>readyState只有5个值{0，1，2，3，4}，只读不能写。</p><p>0: XMLHttpRequest对象创建完成。————还没有调用open()方法</p><p>1: XMLHttpRequest对象初始化完成。————open() 方法已调用，但是 send()方法未调用。请求还没有被发送。</p><p>2: 请求已经发送。———Send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。</p><p>3: 服务器已经返回了数据（但是还没有被解析，可能只一段http报文）。————正在解析响应内容</p><p>4: 数据解析已经完成。————响应内容解析完成,可以在客户端调用了</p><p>数据解析完成之后会返回一个http的状态码，通过XMLHttpRequest.status获得该值，判断是否为200，<strong>判断是否请求成功</strong>。</p><h4 id="onreadystatechange事件："><a href="#onreadystatechange事件：" class="headerlink" title="onreadystatechange事件："></a>onreadystatechange事件：</h4><p>每当readyState属性值改变时，就会触发 onreadystatechange 事件。——通过监听onreadystatechange事件,来判断请求的状态。</p><h3 id="4、发送请求"><a href="#4、发送请求" class="headerlink" title="4、发送请求"></a>4、发送请求</h3><ol><li>send（）方法必须在open（）之后。</li><li><ul><li>在使用GET方式请求时无需填写参数</li><li>在使用POST方式时需要使用setRequestHeader()来添加http头，然后在 send() 方法中规定您希望发送的数据</li></ul></li></ol><p>get:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xmlhttp.open(&quot;GET&quot;,&quot;/try/ajax/ajax_info.txt&quot;,true);</div><div class="line">xmlhttp.send();</div></pre></td></tr></table></figure></p><p>post：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">xmlhttp.open(&quot;POST&quot;,&quot;/try/ajax/demo_post2.php&quot;,true);</div><div class="line">xmlhttp.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</div><div class="line">xmlhttp.send(&quot;fname=Henry&amp;lname=Ford&quot;);</div></pre></td></tr></table></figure></p><p>菜鸟教程的栗子：<a href="http://www.runoob.com/try/try.php?filename=tryajax_first" target="_blank" rel="external">get方式</a>、<a href="http://www.runoob.com/try/try.php?filename=tryajax_post2" target="_blank" rel="external">post方式</a></p><h3 id="写在后面："><a href="#写在后面：" class="headerlink" title="写在后面："></a>写在后面：</h3><p>想到当初自己不会Ajax的时候，畏Ajax如洪水猛兽，希望小伙伴们，看了本文就能写出自己的第一个Ajax来，这也是我想写这篇文章的意义所在。十多天没写文了，这篇文章也准备了好几天，写的不好之后，欢迎指正，谢谢。</p><p><strong>最后</strong>：如需转载，请放上原文链接并署名。码字不易，<strong>感谢</strong>支持！本人写文章本着交流记录的心态，写的不好之处，不撕逼，但是欢迎指点。然后就是希望看完的朋友点个<strong>喜欢</strong>，也可以<strong>关注</strong>一下我。<br><strong><a href="http://obkoro1.com/" target="_blank" rel="external">个人blog</a></strong> and <strong><a href="https://juejin.im/user/58714f0eb123db4a2eb95372" target="_blank" rel="external">掘金个人主页</a></strong>  </p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p> <a href="http://www.jianshu.com/p/4905270afb71#" target="_blank" rel="external">Ajax与数据传输</a></p><p> <a href="http://blog.guowenfh.com/2015/12/18/Ajax-elementary-course-1/" target="_blank" rel="external">Ajax入门（一）从0开始到一次成功的GET请求</a></p><p> <a href="https://juejin.im/entry/583a9e02ac502e006c214b81" target="_blank" rel="external">Ajax 总结篇</a></p><p> <a href="http://www.runoob.com/ajax/ajax-tutorial.html" target="_blank" rel="external">菜鸟教程——AJAX 教程</a></p><p>以上。2017.6.1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面：&quot;&gt;&lt;a href=&quot;#写在前面：&quot; class=&quot;headerlink&quot; title=&quot;写在前面：&quot;&gt;&lt;/a&gt;写在前面：&lt;/h2&gt;&lt;p&gt;本文主要总结整理Ajax使用方法背景知识点的详细解析，以及Ajax跨域的具体使用方式并且对栗子进行了讲解，需要的朋友
      
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="小白实现ajax请求" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%99%BD%E5%AE%9E%E7%8E%B0ajax%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
</feed>
